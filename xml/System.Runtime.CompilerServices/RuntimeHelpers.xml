<Type Name="RuntimeHelpers" FullName="System.Runtime.CompilerServices.RuntimeHelpers">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1654c2b9408230e6affdc108b99fd2438bc2defd" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57934201" /></Metadata><TypeSignature Language="C#" Value="public static class RuntimeHelpers" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit RuntimeHelpers extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.CompilerServices.RuntimeHelpers" />
  <TypeSignature Language="VB.NET" Value="Public Class RuntimeHelpers" />
  <TypeSignature Language="C++ CLI" Value="public ref class RuntimeHelpers abstract sealed" />
  <TypeSignature Language="F#" Value="type RuntimeHelpers = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="615ef-101">Предоставляет набор статических методов и свойств для поддержки компиляторов.</span><span class="sxs-lookup"><span data-stu-id="615ef-101">Provides a set of static methods and properties that provide support for compilers.</span></span> <span data-ttu-id="615ef-102">Этот класс не наследуется.</span><span class="sxs-lookup"><span data-stu-id="615ef-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="615ef-103">В следующем примере показано, как надежным способом настроить маркеры с помощью <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-103">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="615ef-104">Чтобы надежно задать дескриптор для заданного ранее существующего дескриптора, необходимо убедиться, что выделения собственного дескриптора и последующей записи этого дескриптора внутри <xref:System.Runtime.InteropServices.SafeHandle> объекта является атомарной.</span><span class="sxs-lookup"><span data-stu-id="615ef-104">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="615ef-105">Любой сбой между этими операциями (например, прерывания выполнения или исключение out of memory) приведет к утечке собственного дескриптора.</span><span class="sxs-lookup"><span data-stu-id="615ef-105">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span>  <span data-ttu-id="615ef-106">Можно использовать <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> метод, чтобы убедиться в том, что не происходит утечка дескриптора.</span><span class="sxs-lookup"><span data-stu-id="615ef-106">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="EnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static void EnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnsureSufficientExecutionStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member EnsureSufficientExecutionStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="615ef-107">Обеспечивает достаточный запас пространства стека для выполнения средней функции платформы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="615ef-107">Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> Предоставляет сведения о искусственно ограниченного стека, с сохранением достаточно места для вызываемого исключения и выполняемое действие восстановления.</span><span class="sxs-lookup"><span data-stu-id="615ef-108"><xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</span></span> <span data-ttu-id="615ef-109">Предел искусственного стека выбирается, среда CLR, чтобы обеспечить достаточно места для безопасного создания исключения.</span><span class="sxs-lookup"><span data-stu-id="615ef-109">The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</span></span>  
  
 <span data-ttu-id="615ef-110">Этот метод полезен в ситуациях, где может произойти переполнение стека в результате неограниченной рекурсии.</span><span class="sxs-lookup"><span data-stu-id="615ef-110">This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</span></span> <span data-ttu-id="615ef-111">Он предназначен для использования в сценариях службы компилятора, несмотря на то, что он может также использоваться безопасно в других сценариях разработки.</span><span class="sxs-lookup"><span data-stu-id="615ef-111">It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</span></span>  
  
 <span data-ttu-id="615ef-112">Если достаточно пространство стека, исключение не создается, и большинство типов платформы .NET Framework и члены могут быть вызваны.</span><span class="sxs-lookup"><span data-stu-id="615ef-112">If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="615ef-113">Этот метод не является частью поддержки области ограниченного выполнения, а не следует путать с <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-113">This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InsufficientExecutionStackException"><span data-ttu-id="615ef-114">Доступного стекового пространства для выполнения средней функции .NET Framework. недостаточно.</span><span class="sxs-lookup"><span data-stu-id="615ef-114">The available stack space is insufficient to execute the average .NET Framework function.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object o1, object o2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object o1, object o2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (o1 As Object, o2 As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ o1, System::Object ^ o2);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.Equals (o1, o2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o1" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="o2" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="o1"><span data-ttu-id="615ef-115">Первый из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="615ef-115">The first object to compare.</span></span></param>
        <param name="o2"><span data-ttu-id="615ef-116">Второй из сравниваемых объектов.</span><span class="sxs-lookup"><span data-stu-id="615ef-116">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="615ef-117">Определяет, считаются ли равными указанные экземпляры <see cref="T:System.Object" />.</span><span class="sxs-lookup"><span data-stu-id="615ef-117">Determines whether the specified <see cref="T:System.Object" /> instances are considered equal.</span></span></summary>
        <returns><span data-ttu-id="615ef-118">Значение <see langword="true" />, если параметр <paramref name="o1" /> является тем же экземпляром, что и параметр <paramref name="o2" />, или если оба они равны <see langword="null" />, или если <c>o1.Equals(o2)</c> возвращает <see langword="true" />; в противном случае значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="615ef-118"><see langword="true" /> if the <paramref name="o1" /> parameter is the same instance as the <paramref name="o2" /> parameter, or if both are <see langword="null" />, or if <c>o1.Equals(o2)</c> returns <see langword="true" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-119">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-119">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="615ef-120">Следующий пример демонстрирует способ сравнения двух объектов с помощью <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-120">The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteCodeWithGuaranteedCleanup">
      <MemberSignature Language="C#" Value="public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ExecuteCodeWithGuaranteedCleanup(class System.Runtime.CompilerServices.RuntimeHelpers/TryCode code, class System.Runtime.CompilerServices.RuntimeHelpers/CleanupCode backoutCode, object userData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ExecuteCodeWithGuaranteedCleanup (code As RuntimeHelpers.TryCode, backoutCode As RuntimeHelpers.CleanupCode, userData As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ExecuteCodeWithGuaranteedCleanup(System::Runtime::CompilerServices::RuntimeHelpers::TryCode ^ code, System::Runtime::CompilerServices::RuntimeHelpers::CleanupCode ^ backoutCode, System::Object ^ userData);" />
      <MemberSignature Language="F#" Value="static member ExecuteCodeWithGuaranteedCleanup : System.Runtime.CompilerServices.RuntimeHelpers.TryCode * System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode * obj -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup (code, backoutCode, userData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="code" Type="System.Runtime.CompilerServices.RuntimeHelpers+TryCode" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="backoutCode" Type="System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userData" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="code"><span data-ttu-id="615ef-121">Делегат для кода для выполнения попытки.</span><span class="sxs-lookup"><span data-stu-id="615ef-121">A delegate to the code to try.</span></span></param>
        <param name="backoutCode"><span data-ttu-id="615ef-122">Делегат для кода, выполняемого в случае исключения.</span><span class="sxs-lookup"><span data-stu-id="615ef-122">A delegate to the code to run if an exception occurs.</span></span></param>
        <param name="userData"><span data-ttu-id="615ef-123">Данные, передаваемые в код <paramref name="code" /> и <paramref name="backoutCode" />.</span><span class="sxs-lookup"><span data-stu-id="615ef-123">The data to pass to <paramref name="code" /> and <paramref name="backoutCode" />.</span></span></param>
        <summary><span data-ttu-id="615ef-124">Выполняет код с помощью делегата <see cref="T:System.Delegate" />, используя другой делегат <see cref="T:System.Delegate" /> для выполнения дополнительного кода в случае исключения.</span><span class="sxs-lookup"><span data-stu-id="615ef-124">Executes code using a <see cref="T:System.Delegate" /> while using another <see cref="T:System.Delegate" /> to execute additional code in case of an exception.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-125">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-125">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-126">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-126">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-127">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-127">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public static int GetHashCode (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetHashCode(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetHashCode (o As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetHashCode(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetHashCode : obj -&gt; int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="615ef-128">Объект, для которого нужно извлечь хэш-код.</span><span class="sxs-lookup"><span data-stu-id="615ef-128">An object to retrieve the hash code for.</span></span></param>
        <summary><span data-ttu-id="615ef-129">Служит в качестве хэш-функции для конкретного объекта и подходит для использования в алгоритмах и структурах данных, использующих хэш-коды, например в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="615ef-129">Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</span></span></summary>
        <returns><span data-ttu-id="615ef-130">Хэш-код для объекта, идентифицируемого по параметру <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="615ef-130">A hash code for the object identified by the <paramref name="o" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-131"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Всегда вызывает метод <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> метод невиртуальным, даже если тип объекта переопределил <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-131">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="615ef-132">Таким образом, использование <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> могут отличаться от вызова `GetHashCode` непосредственно в объекте с <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-132">Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="615ef-133">Несмотря на то что <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> метод возвращает одинаковые хэш-коды для идентичных ссылок на объекты, не следует использовать этот метод для проверки тождества объектов, так как этот хэш-код для уникальной идентификации ссылку на объект.</span><span class="sxs-lookup"><span data-stu-id="615ef-133">Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</span></span> <span data-ttu-id="615ef-134">Для проверки идентификации объекта (то есть для проверки двух объектов ссылку тот же объект в памяти), вызовите <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-134">To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="615ef-135">И не следует использовать <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> для тестирования ли две строки представляют ссылки на объекты равны, так как строки уже интернировано.</span><span class="sxs-lookup"><span data-stu-id="615ef-135">Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned.</span></span> <span data-ttu-id="615ef-136">Чтобы проверить интернирование строк, вызовите <xref:System.String.IsInterned%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-136">To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="615ef-137"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> И <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> методы имеют следующие различия:</span><span class="sxs-lookup"><span data-stu-id="615ef-137">The <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods differ as follows:</span></span>  
  
-   <span data-ttu-id="615ef-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> Возвращает хэш-код, основанный на определение объекта на равенство.</span><span class="sxs-lookup"><span data-stu-id="615ef-138"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that is based on the object's definition of equality.</span></span> <span data-ttu-id="615ef-139">Например, две строки с идентичным содержимым будет возвращать то же значение для <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="615ef-139">For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="615ef-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> Возвращает хэш-код, указывающее идентификатор объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-140"><xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> returns a hash code that indicates object identity.</span></span> <span data-ttu-id="615ef-141">То есть две строковые переменные, содержимое которого идентичны и представляющие собой строку, которая уже интернировано (см. в разделе [Интернировании](#interning) раздел) или, представляющих одну строку в памяти возвращают одинаковые хэш-коды.</span><span class="sxs-lookup"><span data-stu-id="615ef-141">That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="615ef-142">Обратите внимание, что <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> всегда возвращает одинаковые хэш-коды для ссылки на объекты равны.</span><span class="sxs-lookup"><span data-stu-id="615ef-142">Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references.</span></span> <span data-ttu-id="615ef-143">Однако обратное неверно: равно хэш-коды не указывают ссылки на объекты равны.</span><span class="sxs-lookup"><span data-stu-id="615ef-143">However, the reverse is not true: equal hash codes do not indicate equal object references.</span></span> <span data-ttu-id="615ef-144">Значение конкретного хэш-кода не является уникальным для ссылки на конкретный объект; ссылки на различные объекты можно создавать одинаковые хэш-кодов.</span><span class="sxs-lookup"><span data-stu-id="615ef-144">A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</span></span>  
  
 <span data-ttu-id="615ef-145">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-145">This method is used by compilers.</span></span>  
  
<a name="interning"></a>   
## <a name="string-interning"></a><span data-ttu-id="615ef-146">Настроить интернирование строк</span><span class="sxs-lookup"><span data-stu-id="615ef-146">String Interning</span></span>  
 <span data-ttu-id="615ef-147">Среда CLR (CLR) поддерживает внутренний пул строк и хранит литералы в пуле.</span><span class="sxs-lookup"><span data-stu-id="615ef-147">The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</span></span> <span data-ttu-id="615ef-148">Если две строки (например, `str1` и `str2`) формируются идентичные строки литерала, среда CLR будет задан `str1` и `str2` указывал на том же расположении в управляемой куче для экономии памяти.</span><span class="sxs-lookup"><span data-stu-id="615ef-148">If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory.</span></span> <span data-ttu-id="615ef-149">Вызов <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> на этих двух строковых объектов создаст одинаковый хэш-код, в отличие от второй элемент маркированного в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="615ef-149">Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</span></span>  
  
 <span data-ttu-id="615ef-150">Среда CLR добавляет только литералы в пул.</span><span class="sxs-lookup"><span data-stu-id="615ef-150">The CLR adds only literals to the pool.</span></span> <span data-ttu-id="615ef-151">Результаты строковых операций, таких как объединение не добавляются в пул, если компилятор разрешает сцепления строки в виде одной строки литерала.</span><span class="sxs-lookup"><span data-stu-id="615ef-151">Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</span></span> <span data-ttu-id="615ef-152">Таким образом Если `str2` был создан в результате операции объединения и `str2` идентична `str1`, с использованием <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> на этих двух строковых объектов не даст одинаковый хэш-код.</span><span class="sxs-lookup"><span data-stu-id="615ef-152">Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> on these two string objects will not produce the same hash code.</span></span>  
  
 <span data-ttu-id="615ef-153">Если вы хотите явно добавить в пул объединенную строку, используйте <xref:System.String.Intern%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-153">If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="615ef-154">Можно также использовать <xref:System.String.IsInterned%2A?displayProperty=nameWithType> метод для проверки, содержит ли строка интернировано ссылку.</span><span class="sxs-lookup"><span data-stu-id="615ef-154">You can also use the <xref:System.String.IsInterned%2A?displayProperty=nameWithType> method to check whether a string has an interned reference.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="615ef-155">В следующем примере показано различие между <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> и <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> методы.</span><span class="sxs-lookup"><span data-stu-id="615ef-155">The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="615ef-156">Выходные данные примера иллюстрирует следующее:</span><span class="sxs-lookup"><span data-stu-id="615ef-156">The output from the example illustrates the following:</span></span>  
  
-   <span data-ttu-id="615ef-157">Оба вида хэш-коды для первого набора строк, передаваемый `ShowHashCodes` метод отличаются, так как строки совершенно различны.</span><span class="sxs-lookup"><span data-stu-id="615ef-157">Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.</span></span>  
  
-   <span data-ttu-id="615ef-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> создает одинаковый хэш-код для второго набора строк, передаваемых `ShowHashCodes` метод, так как сроки равны.</span><span class="sxs-lookup"><span data-stu-id="615ef-158"><xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal.</span></span> <span data-ttu-id="615ef-159">Тем не менее <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> метод — нет.</span><span class="sxs-lookup"><span data-stu-id="615ef-159">However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType> method does not.</span></span> <span data-ttu-id="615ef-160">Первая строка определяется с помощью строкового литерала и поэтому уже интернировано.</span><span class="sxs-lookup"><span data-stu-id="615ef-160">The first string is defined by using a string literal and so is interned.</span></span> <span data-ttu-id="615ef-161">Несмотря на то, что значение второй строки совпадает, он является которых интернирование не применяется, так как он возвращается вызовом <xref:System.String.Format%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-161">Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="615ef-162">В случае с третьей строки, хэш-кодов, полученных при <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> для обе строки идентичны, как и в случае являются хэш-коды, созданные <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="615ef-162">In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="615ef-163">Это потому, что компилятор рассматривать значение, присваиваемое обе строки в виде одной строки литерала, поэтому строка переменные ссылаются на одну и ту же строку интернировано.</span><span class="sxs-lookup"><span data-stu-id="615ef-163">This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.</span></span>  
  
 [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]
 [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectValue">
      <MemberSignature Language="C#" Value="public static object GetObjectValue (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObjectValue(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetObjectValue (obj As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObjectValue(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetObjectValue : obj -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="615ef-164">Упаковываемый тип значения.</span><span class="sxs-lookup"><span data-stu-id="615ef-164">The value type to be boxed.</span></span></param>
        <summary><span data-ttu-id="615ef-165">Упаковывает тип значения.</span><span class="sxs-lookup"><span data-stu-id="615ef-165">Boxes a value type.</span></span></summary>
        <returns><span data-ttu-id="615ef-166">Упакованная копия <paramref name="obj" />, если это класс значения; в противном случае — <paramref name="obj" />.</span><span class="sxs-lookup"><span data-stu-id="615ef-166">A boxed copy of <paramref name="obj" /> if it is a value class; otherwise, <paramref name="obj" /> itself.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-167">При упаковке типа значения создает объект и выполняет неполную копию полей заданного типа значения в новый объект.</span><span class="sxs-lookup"><span data-stu-id="615ef-167">Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</span></span>  
  
 <span data-ttu-id="615ef-168">Этот метод позволяет классу значение обрабатываться как объект, при сохранении его поведения с псевдонимами класса значений.</span><span class="sxs-lookup"><span data-stu-id="615ef-168">This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</span></span>  
  
 <span data-ttu-id="615ef-169">Возвращаемое значение зависит от того, является ли класс значения изменяемым или неизменяемым:</span><span class="sxs-lookup"><span data-stu-id="615ef-169">The return value depends on whether the value class is mutable or immutable:</span></span>  
  
-   <span data-ttu-id="615ef-170">Если значения, присваиваемого является классом изменяемого значения, метод возвращает неполную копию класса, так как классы значений имеют семантику копирования.</span><span class="sxs-lookup"><span data-stu-id="615ef-170">If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</span></span>  
  
-   <span data-ttu-id="615ef-171">Если значения, присваиваемого является неизменяемым классом значения, метод возвращает объектом, а не копию класса.</span><span class="sxs-lookup"><span data-stu-id="615ef-171">If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</span></span>  
  
 <span data-ttu-id="615ef-172">Компиляторы языков с динамической типизацией этот метод можно использовать, чтобы убедиться в том, что типы упакованных значений одинаково работать упакованных типов значений.</span><span class="sxs-lookup"><span data-stu-id="615ef-172">Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</span></span> <span data-ttu-id="615ef-173">То есть при передаче этих вокруг и всегда передаются по значению, клонируются упакованных типов значений.</span><span class="sxs-lookup"><span data-stu-id="615ef-173">That is, boxed value types get cloned when you pass them around, and they are always passed by value.</span></span> <span data-ttu-id="615ef-174">Компилятор может вызывать <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> присвоить тип значения объекта или для передачи типа значения в качестве параметра объект типа.</span><span class="sxs-lookup"><span data-stu-id="615ef-174">The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.</span></span>  
  
 <span data-ttu-id="615ef-175">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-175">This method is used by compilers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="615ef-176">Следующий пример демонстрирует поле класса значений с помощью <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-176">The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.</span></span>  
  
 [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]
 [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetUninitializedObject">
      <MemberSignature Language="C#" Value="public static object GetUninitializedObject (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetUninitializedObject(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetUninitializedObject(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetUninitializedObject : Type -&gt; obj" Usage="System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="type">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeArray">
      <MemberSignature Language="C#" Value="public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void InitializeArray(class System.Array array, valuetype System.RuntimeFieldHandle fldHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void InitializeArray(Array ^ array, RuntimeFieldHandle fldHandle);" />
      <MemberSignature Language="F#" Value="static member InitializeArray : Array * RuntimeFieldHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray (array, fldHandle)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Array" />
        <Parameter Name="fldHandle" Type="System.RuntimeFieldHandle" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="615ef-177">Инициализируемый массив.</span><span class="sxs-lookup"><span data-stu-id="615ef-177">The array to be initialized.</span></span></param>
        <param name="fldHandle"><span data-ttu-id="615ef-178">Дескриптор поля, указывающий расположение данных, используемых для инициализации массива.</span><span class="sxs-lookup"><span data-stu-id="615ef-178">A field handle that specifies the location of the data used to initialize the array.</span></span></param>
        <summary><span data-ttu-id="615ef-179">Предоставляет быстрый способ инициализации массива данных, хранящихся в модуле.</span><span class="sxs-lookup"><span data-stu-id="615ef-179">Provides a fast way to initialize an array from data that is stored in a module.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-180">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-180">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReferenceOrContainsReferences&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static bool IsReferenceOrContainsReferences&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsReferenceOrContainsReferences&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsReferenceOrContainsReferences(Of T) () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static bool IsReferenceOrContainsReferences();" />
      <MemberSignature Language="F#" Value="static member IsReferenceOrContainsReferences : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetToStringData">
      <MemberSignature Language="C#" Value="public static int OffsetToStringData { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 OffsetToStringData" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OffsetToStringData As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int OffsetToStringData { int get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetToStringData : int" Usage="System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="615ef-181">Получает смещение в байтах к данным в указанной строке.</span><span class="sxs-lookup"><span data-stu-id="615ef-181">Gets the offset, in bytes, to the data in the given string.</span></span></summary>
        <value><span data-ttu-id="615ef-182">Смещение в байтах от начала объекта <see cref="T:System.String" /> до первого символа строки.</span><span class="sxs-lookup"><span data-stu-id="615ef-182">The byte offset, from the start of the <see cref="T:System.String" /> object to the first character in the string.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-183">Компиляторы используют это свойство для операции с указателем unsafe, но эффективной от символов в управляемую строку.</span><span class="sxs-lookup"><span data-stu-id="615ef-183">Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</span></span> <span data-ttu-id="615ef-184">Компиляторы должны оградить строки от перемещения сборщиком мусора перед использованием.</span><span class="sxs-lookup"><span data-stu-id="615ef-184">Compilers should pin the string against movement by the garbage collector before use.</span></span> <span data-ttu-id="615ef-185">Обратите внимание, что строки среды CLR являются неизменными. то есть их содержимое можно читать но не изменять.</span><span class="sxs-lookup"><span data-stu-id="615ef-185">Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegions">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegions ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegions() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegions ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegions();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegions : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="615ef-186">Назначает основную часть кода как область с ограничением исполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-186">Designates a body of code as a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-187">Компиляторы используют этот метод, чтобы пометить `catch`, `finally`, и `fault` блоков, как области ограниченного выполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-187">Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs).</span></span> <span data-ttu-id="615ef-188">Код, помеченный как область с ограничением, должен вызывать только другой код со строгими контрактами надежности.</span><span class="sxs-lookup"><span data-stu-id="615ef-188">Code that is marked as a constrained region must only call other code with strong reliability contracts.</span></span> <span data-ttu-id="615ef-189">Его не следует выделить или выполнять виртуальные вызовы для неподготовленных или ненадежных методов, если он не подготовлен для обработки сбоев.</span><span class="sxs-lookup"><span data-stu-id="615ef-189">It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</span></span>  
  
 <span data-ttu-id="615ef-190">Обратите внимание, что не промежуточный язык коды операций, за исключением `NOP`, допускаются между вызовом <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> метод и `try` блока.</span><span class="sxs-lookup"><span data-stu-id="615ef-190">Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block.</span></span> <span data-ttu-id="615ef-191">Дополнительные сведения об областях CER см. классы в <xref:System.Runtime.ConstrainedExecution> пространства имен.</span><span class="sxs-lookup"><span data-stu-id="615ef-191">For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.</span></span>  
  
 <span data-ttu-id="615ef-192">CER-области, которые помечены с помощью <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> метод совершенно не работают при <xref:System.StackOverflowException> создается на основе `try` блока.</span><span class="sxs-lookup"><span data-stu-id="615ef-192">CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block.</span></span> <span data-ttu-id="615ef-193">Дополнительные сведения см. в описании метода <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A>.</span><span class="sxs-lookup"><span data-stu-id="615ef-193">For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.</span></span>  
  
 <span data-ttu-id="615ef-194">Метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> вызывает метод <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A>.</span><span class="sxs-lookup"><span data-stu-id="615ef-194">The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="615ef-195">В следующем примере показано, как надежным способом настроить маркеры с помощью <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-195">The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method.</span></span> <span data-ttu-id="615ef-196">Чтобы надежно задать дескриптор для заданного ранее существующего дескриптора, необходимо убедиться, что выделения собственного дескриптора и последующей записи этого дескриптора внутри <xref:System.Runtime.InteropServices.SafeHandle> объекта является атомарной.</span><span class="sxs-lookup"><span data-stu-id="615ef-196">To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic.</span></span> <span data-ttu-id="615ef-197">Любой сбой между этими операциями (например, прерывания выполнения или исключение out of memory) приведет к утечке собственного дескриптора.</span><span class="sxs-lookup"><span data-stu-id="615ef-197">Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.</span></span> <span data-ttu-id="615ef-198">Можно использовать <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> метод, чтобы убедиться в том, что не происходит утечка дескриптора.</span><span class="sxs-lookup"><span data-stu-id="615ef-198">You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.</span></span>  
  
 [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]
 [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-199">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-199">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-200">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-200">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareConstrainedRegionsNoOP">
      <MemberSignature Language="C#" Value="public static void PrepareConstrainedRegionsNoOP ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareConstrainedRegionsNoOP() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareConstrainedRegionsNoOP ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareConstrainedRegionsNoOP();" />
      <MemberSignature Language="F#" Value="static member PrepareConstrainedRegionsNoOP : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="615ef-201">Назначает основную часть кода областью с ограничением исполнения (CER) без какой-либо проверки.</span><span class="sxs-lookup"><span data-stu-id="615ef-201">Designates a body of code as a constrained execution region (CER) without performing any probing.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-202">Компиляторы не следует вызывать этот метод напрямую.</span><span class="sxs-lookup"><span data-stu-id="615ef-202">Compilers should not call this method directly.</span></span> <span data-ttu-id="615ef-203">Вместо этого определения области ограниченного Выполнения путем вызова <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-203">Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-204">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-204">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-205">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-205">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareContractedDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareContractedDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareContractedDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareContractedDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareContractedDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareContractedDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="615ef-206">Делегат события, который следует подготовить.</span><span class="sxs-lookup"><span data-stu-id="615ef-206">The event delegate to prepare.</span></span></param>
        <summary><span data-ttu-id="615ef-207">Предоставляет приложению способ динамической подготовки делегатов событий <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="615ef-207">Provides a way for applications to dynamically prepare <see cref="T:System.AppDomain" /> event delegates.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-208"><xref:System.AppDomain> событие делегаты, такие как <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, и <xref:System.AppDomain.UnhandledException> не подготавливаются автоматически при запуске.</span><span class="sxs-lookup"><span data-stu-id="615ef-208"><xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup.</span></span> <span data-ttu-id="615ef-209">Чтобы подготовить их можно использовать следующие методы:</span><span class="sxs-lookup"><span data-stu-id="615ef-209">You can use the following methods to prepare them:</span></span>  
  
-   <span data-ttu-id="615ef-210">Атрибут с помощью метода <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> атрибут.</span><span class="sxs-lookup"><span data-stu-id="615ef-210">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="615ef-211">Атрибут с помощью метода <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> атрибут.</span><span class="sxs-lookup"><span data-stu-id="615ef-211">Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.</span></span>  
  
-   <span data-ttu-id="615ef-212">Вызовите <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> способ динамической подготовки делегата.</span><span class="sxs-lookup"><span data-stu-id="615ef-212">Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.</span></span>  
  
 <span data-ttu-id="615ef-213">Дополнительные сведения см. в статье [сохранить работы кода с помощью функций обеспечения надежности платформы .NET Framework](https://go.microsoft.com/fwlink/?LinkId=145491) в журнале MSDN Magazine.</span><span class="sxs-lookup"><span data-stu-id="615ef-213">For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](https://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-214">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-214">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-215">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-215">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareDelegate">
      <MemberSignature Language="C#" Value="public static void PrepareDelegate (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareDelegate(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareDelegate (d As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareDelegate(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="static member PrepareDelegate : Delegate -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d"><span data-ttu-id="615ef-216">Тип делегата, который следует подготовить.</span><span class="sxs-lookup"><span data-stu-id="615ef-216">The delegate type to prepare.</span></span></param>
        <summary><span data-ttu-id="615ef-217">Указывает, что заданный делегат следует подготовить к включению в область с ограничением исполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-217">Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-218">Компиляторы используют этот метод для подготовки метод вызова делегата, так и для подготовки целевого объекта вызова (и статически определимый граф вызова делегата), как область с ограничением исполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-218">Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-219">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-219">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-220">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-220">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="PrepareMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="615ef-221">Подготавливает метод к включению в область с ограничением исполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-221">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod method" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="615ef-222">Дескриптор метода, который следует подготовить.</span><span class="sxs-lookup"><span data-stu-id="615ef-222">A handle to the method to prepare.</span></span></param>
        <summary><span data-ttu-id="615ef-223">Подготавливает метод к включению в область с ограничением исполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-223">Prepares a method for inclusion in a constrained execution region (CER).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-224">Компиляторы используют <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> метод для обработки виртуальные вызовы, сделанные внутри области ограниченного выполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-224">Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER).</span></span> <span data-ttu-id="615ef-225">Во время JIT-компиляции среда CLR не поддерживает обычно достаточно информации о целевой объект виртуального вызова.</span><span class="sxs-lookup"><span data-stu-id="615ef-225">At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</span></span> <span data-ttu-id="615ef-226">Таким образом среда выполнения не подготавливает изначально этот сегмент графа вызовов.</span><span class="sxs-lookup"><span data-stu-id="615ef-226">Therefore, the runtime does not initially prepare that segment of the call graph.</span></span> <span data-ttu-id="615ef-227">Если код, который использует CER имеет достаточно сведений, чтобы определить целевой объект в любой момент времени до CER действительно вошло, оно может вызвать <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> для выполнения одной подготовки среды выполнения, обычно выполняется для CER-области с корнем в метод, заданное в качестве аргумента.</span><span class="sxs-lookup"><span data-stu-id="615ef-227">If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-228">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-228">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-229">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-229">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="PrepareMethod">
      <MemberSignature Language="C#" Value="public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PrepareMethod(valuetype System.RuntimeMethodHandle method, valuetype System.RuntimeTypeHandle[] instantiation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PrepareMethod (method As RuntimeMethodHandle, instantiation As RuntimeTypeHandle())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrepareMethod(RuntimeMethodHandle method, cli::array &lt;RuntimeTypeHandle&gt; ^ instantiation);" />
      <MemberSignature Language="F#" Value="static member PrepareMethod : RuntimeMethodHandle * RuntimeTypeHandle[] -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod (method, instantiation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="method" Type="System.RuntimeMethodHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="instantiation" Type="System.RuntimeTypeHandle[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="method"><span data-ttu-id="615ef-230">Дескриптор метода, который следует подготовить.</span><span class="sxs-lookup"><span data-stu-id="615ef-230">A handle to the method to prepare.</span></span></param>
        <param name="instantiation"><span data-ttu-id="615ef-231">Экземпляр для передачи в метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-231">The instantiation to pass to the method.</span></span></param>
        <summary><span data-ttu-id="615ef-232">Подготавливает метод для включения в область с ограничением исполнения (CER) с указанной реализацией.</span><span class="sxs-lookup"><span data-stu-id="615ef-232">Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-233">Вы можете предоставить поддержки универсальных типов с помощью компиляторов <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-233">You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method.</span></span> <span data-ttu-id="615ef-234">Среда CLR не удалось подготовить области ограниченного выполнения (CER) с корнем в методе, который имеет параметры универсального типа (либо параметром типа для класса, содержащего метод, или на сам метод) при создании экземпляра таких параметров типа как ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="615ef-234">The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</span></span>  
  
 <span data-ttu-id="615ef-235">Эта перегрузка позволяет передать конкретную реализацию (например, массив типов), сначала указав параметры типа класса (если таковые имеются), а затем параметры типа метода (если таковые имеются).</span><span class="sxs-lookup"><span data-stu-id="615ef-235">You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</span></span> <span data-ttu-id="615ef-236">Среда выполнения подготавливает соответствующую реализацию метода.</span><span class="sxs-lookup"><span data-stu-id="615ef-236">The runtime prepares that instantiation of the method.</span></span> <span data-ttu-id="615ef-237">(Это необходимо только в том случае, если используемые содержат по крайней мере один параметр ссылочного типа.) Таким образом, можно использовать стиль CER `try` предложение в универсальный метод (или неуниверсального метода для универсального класса) и он будет надежно работать с реализациями <xref:System.Int32> или других типов значений.</span><span class="sxs-lookup"><span data-stu-id="615ef-237">(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types.</span></span> <span data-ttu-id="615ef-238">Для создания экземпляра ссылку типы, такие как <xref:System.String>, необходимо использовать явный <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> метода в CER корневой метод сначала.</span><span class="sxs-lookup"><span data-stu-id="615ef-238">To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-239">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-239">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-240">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-240">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ProbeForSufficientStack">
      <MemberSignature Language="C#" Value="public static void ProbeForSufficientStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ProbeForSufficientStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ProbeForSufficientStack ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ProbeForSufficientStack();" />
      <MemberSignature Language="F#" Value="static member ProbeForSufficientStack : unit -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="615ef-241">Проверяет наличие определенного объема стекового пространства, чтобы предотвратить переполнение стека в последующем блоке кода (предполагая, что код использует только конечный и небольшой объем стекового пространства).</span><span class="sxs-lookup"><span data-stu-id="615ef-241">Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</span></span> <span data-ttu-id="615ef-242">Рекомендуется вместо этого метода использовать область с ограничением исполнения (CER).</span><span class="sxs-lookup"><span data-stu-id="615ef-242">We recommend that you use a constrained execution region (CER) instead of this method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-243">Этот метод используется инфраструктурой области ограниченного выполнения, при работе в узлы, которые более устойчивы к переполнению стека, например Microsoft SQL Server и Microsoft Exchange Server.</span><span class="sxs-lookup"><span data-stu-id="615ef-243">This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</span></span> <span data-ttu-id="615ef-244">Этот метод в настоящее время проверяет наличие 48 КБ пространства стека на x86 платформе, но точное со временем может меняться и могут отличаться на других платформах.</span><span class="sxs-lookup"><span data-stu-id="615ef-244">This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</span></span>  
  
 <span data-ttu-id="615ef-245">Этот метод также используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-245">This method is also used by compilers.</span></span>  
  
 <span data-ttu-id="615ef-246">Вместо использования <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> метод, следует использовать стандартный CER-области.</span><span class="sxs-lookup"><span data-stu-id="615ef-246">Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER.</span></span> <span data-ttu-id="615ef-247">То есть если вы планируете использовать средний объем пространства стека, вызывать <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> метод непосредственно перед вашей `try` / `finally` или `try` / `catch` блока.</span><span class="sxs-lookup"><span data-stu-id="615ef-247">That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=nameWithType> method immediately before your `try`/`finally` or `try`/`catch` block.</span></span> <span data-ttu-id="615ef-248">Если вы вызываете рекурсивный метод или планируете использовать большой объем пространства стека, необходимо использовать <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="615ef-248">If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="615ef-249">Требует полного доверия для непосредственного вызывающего объекта.</span><span class="sxs-lookup"><span data-stu-id="615ef-249">requires full trust for the immediate caller.</span></span> <span data-ttu-id="615ef-250">Этот член не может использоваться частично доверенным или прозрачным кодом.</span><span class="sxs-lookup"><span data-stu-id="615ef-250">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="RunClassConstructor">
      <MemberSignature Language="C#" Value="public static void RunClassConstructor (RuntimeTypeHandle type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunClassConstructor(valuetype System.RuntimeTypeHandle type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunClassConstructor (type As RuntimeTypeHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunClassConstructor(RuntimeTypeHandle type);" />
      <MemberSignature Language="F#" Value="static member RunClassConstructor : RuntimeTypeHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="615ef-251">Дескриптор типа, указывающий тип, для которого следует запустить инициализатор типа.</span><span class="sxs-lookup"><span data-stu-id="615ef-251">A type handle that specifies the type for which a type initializer should be run.</span></span></param>
        <summary><span data-ttu-id="615ef-252">Обеспечивает выполнение инициализатора типа (также называемого статическим конструктором) для указанного типа.</span><span class="sxs-lookup"><span data-stu-id="615ef-252">Ensures that the type initializer (also known as a static constructor) for the specified type has been run.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-253">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-253">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="615ef-254">Инициализатор типа выдает исключение.</span><span class="sxs-lookup"><span data-stu-id="615ef-254">The type initializer throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RunModuleConstructor">
      <MemberSignature Language="C#" Value="public static void RunModuleConstructor (ModuleHandle module);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RunModuleConstructor(valuetype System.ModuleHandle module) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RunModuleConstructor (module As ModuleHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RunModuleConstructor(ModuleHandle module);" />
      <MemberSignature Language="F#" Value="static member RunModuleConstructor : ModuleHandle -&gt; unit" Usage="System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor module" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="module" Type="System.ModuleHandle" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="module"><span data-ttu-id="615ef-255">Дескриптор, определяющий метод конструктора модуля, который нужно выполнить.</span><span class="sxs-lookup"><span data-stu-id="615ef-255">A handle that specifies the module constructor method to run.</span></span></param>
        <summary><span data-ttu-id="615ef-256">Выполняет указанный метод конструктора модуля.</span><span class="sxs-lookup"><span data-stu-id="615ef-256">Runs a specified module constructor method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="615ef-257">Этот метод используется компиляторами.</span><span class="sxs-lookup"><span data-stu-id="615ef-257">This method is used by compilers.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeInitializationException"><span data-ttu-id="615ef-258">Конструктор модуля выдает исключение.</span><span class="sxs-lookup"><span data-stu-id="615ef-258">The module constructor throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnsureSufficientExecutionStack">
      <MemberSignature Language="C#" Value="public static bool TryEnsureSufficientExecutionStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnsureSufficientExecutionStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnsureSufficientExecutionStack () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnsureSufficientExecutionStack();" />
      <MemberSignature Language="F#" Value="static member TryEnsureSufficientExecutionStack : unit -&gt; bool" Usage="System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>