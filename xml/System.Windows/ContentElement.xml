<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata><Meta Name="ms.openlocfilehash" Value="aa85743d6a364530c4a2bb6414241b766420cfc5" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="ru-RU" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57935501" /></Metadata><TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type ContentElement = class&#xA;    inherit DependencyObject&#xA;    interface IInputElement&#xA;    interface IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="4aca4-101">Предоставляет базовый класс уровня ядра WPF для элементов содержимого.</span><span class="sxs-lookup"><span data-stu-id="4aca4-101">Provides a WPF core-level base class for content elements.</span></span> <span data-ttu-id="4aca4-102">Элементы содержимого разработаны для представления в стиле потока с использованием интуитивно понятной модели макета разметки и намеренно простой объектной модели.</span><span class="sxs-lookup"><span data-stu-id="4aca4-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-103"><xref:System.Windows.ContentElement> определяет следующие общие характеристики содержимого:</span><span class="sxs-lookup"><span data-stu-id="4aca4-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="4aca4-104">Вход: Все <xref:System.Windows.ContentElement> производные классы обеспечивают поддержку базовый ввод с клавиатуры, мыши, операции перетаскивания и вставки, сенсорного экрана и ускорители.</span><span class="sxs-lookup"><span data-stu-id="4aca4-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="4aca4-105">Фокус: Все <xref:System.Windows.ContentElement> производные классы могут потенциально может получить фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="4aca4-106">(Однако фокуса по умолчанию для <xref:System.Windows.ContentElement> базовым классом является `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="4aca4-107">Дополнительные сведения о том, как сделать <xref:System.Windows.ContentElement> может получать фокус, см. в разделе <xref:System.Windows.ContentElement.Focusable%2A>.) Кроме того, этот класс содержит [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] , можно использовать для перемещения фокуса между связанных элементов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="4aca4-108">События: <xref:System.Windows.ContentElement> включает в себя события, связанные с входных данных и фокус; он также включает события для изменений в состоянии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="4aca4-109">Во многих случаях <xref:System.Windows.ContentElement> события – это маршрутизированные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="4aca4-110">В некоторых случаях перенаправленные события имеют нисходящей и восходящей маршрутизации стратегии, возникает как отдельные события в ответ на один и тот же состояние или условие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="4aca4-111">Кроме того <xref:System.Windows.ContentElement> определяет [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] , можно увеличить с маршрутизированными событиями и который можно добавлять или удалять обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="4aca4-112"><xref:System.Windows.ContentElement> совместно использует многие распространенные [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] с <xref:System.Windows.UIElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="4aca4-113">Эти Общие [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] поставляются наследования из общего класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="4aca4-114">Но они совместно используют общие названия, аналогичное поведение и внутреннее применение [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] в каждом классе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="4aca4-115">Сходство обусловлено <xref:System.Windows.ContentElement> и <xref:System.Windows.UIElement> являются каждого классы, которые являются основе элемента, несмотря на то, что использует другой подход к модели поведения объекта разметки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="4aca4-116">В частности <xref:System.Windows.UIElement> потомком <xref:System.Windows.Media.Visual>, который предоставляет графические объекты более низкого уровня поддержки для подготовки к просмотру <xref:System.Windows.ContentElement> в прямоугольную область в пределах окна, тогда как <xref:System.Windows.ContentElement> откладывает отрисовки таким образом, чтобы Дополнительные понятия Общие для документа сценарии, такие как потоком и обтеканием, более легко поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="4aca4-117">Эти два связанных класса также реализуют широко распространенными интерфейсами <xref:System.Windows.IInputElement> и <xref:System.Windows.Media.Animation.IAnimatable>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-118"><see cref="T:System.Windows.ContentElement" /> Класс еще не определяет все аспекты полный элемент содержимого для представления в стиле потока.</span><span class="sxs-lookup"><span data-stu-id="4aca4-118">The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation.</span></span> <span data-ttu-id="4aca4-119"><see cref="T:System.Windows.FrameworkContentElement" /> является непосредственно производным от класса <see cref="T:System.Windows.ContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-119"><see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />.</span></span> <span data-ttu-id="4aca4-120"><see cref="T:System.Windows.FrameworkContentElement" /> включает в себя более полный набор дополнительные члены, поддерживающие отрисовки <see cref="T:System.Windows.FrameworkContentElement" /> в пределах узла содержимого и в системе макетов уровня среды WPF.</span><span class="sxs-lookup"><span data-stu-id="4aca4-120"><see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</span></span></para></block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-121">Инициализирует новый экземпляр класса <see cref="T:System.Windows.ContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-121">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4aca4-122">Добавляет обработчик перенаправленного события для указанного перенаправленного события, помещая этот обработчик в коллекцию обработчиков текущего элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-122">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.AddHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="4aca4-123">Идентификатор маршрутизируемого события для обработки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-123">An identifier for the routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="4aca4-124">Ссылка на реализацию обработчика.</span><span class="sxs-lookup"><span data-stu-id="4aca4-124">A reference to the handler implementation.</span></span></param>
        <summary><span data-ttu-id="4aca4-125">Добавляет обработчик перенаправленного события для указанного перенаправленного события, помещая этот обработчик в коллекцию обработчиков текущего элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-125">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-126">Можно добавить один и тот же обработчик того же события несколько раз, не вызывая исключение.</span><span class="sxs-lookup"><span data-stu-id="4aca4-126">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="4aca4-127">Тем не менее обработчик вызывается несколько раз, когда событие обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-127">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="4aca4-128">Таким образом рассмотрим, как это поведение может иметь побочные эффекты, которые следует учесть при реализации обработчика.</span><span class="sxs-lookup"><span data-stu-id="4aca4-128">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="4aca4-129">Этот метод обычно используется для реализации метода доступа «add» для [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] шаблона доступа события пользовательских перенаправленных событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-129">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberSignature Language="F#" Value="member this.AddHandler : System.Windows.RoutedEvent * Delegate * bool -&gt; unit" Usage="contentElement.AddHandler (routedEvent, handler, handledEventsToo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="4aca4-130">Идентификатор для обрабатываемого перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-130">An identifier for the.routed event to be handled.</span></span></param>
        <param name="handler"><span data-ttu-id="4aca4-131">Ссылка на реализацию обработчика.</span><span class="sxs-lookup"><span data-stu-id="4aca4-131">A reference to the handler implementation.</span></span></param>
        <param name="handledEventsToo"><span data-ttu-id="4aca4-132"><see langword="true" /> для регистрации обработчика, чтобы он вызывался даже в том случае, если перенаправленное событие помечено как обработанное в его данных события. <see langword="false" /> для регистрации обработчика с условием по умолчанию, что он не будет вызываться, если перенаправленное событие уже помечено как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-132"><see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span></span>  
  
<span data-ttu-id="4aca4-133">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-133">The default is <see langword="false" />.</span></span>  
  
<span data-ttu-id="4aca4-134">Не следует постоянно прибегать к повторной обработке перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-134">Do not routinely ask to rehandle a routed event.</span></span></param>
        <summary><span data-ttu-id="4aca4-135">Добавляет обработчик перенаправленного события для указанного перенаправленного события, помещая этот обработчик в коллекцию обработчиков текущего элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-135">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span></span> <span data-ttu-id="4aca4-136">Укажите <paramref name="handledEventsToo" /> как <see langword="true" />, чтобы предоставленный обработчик вызывался для перенаправленного события, которое уже было отмечено как обработанное другим элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-136">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-137">Обработка событий низкоуровневого ввода практическая — это сложная задача.</span><span class="sxs-lookup"><span data-stu-id="4aca4-137">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="4aca4-138">Многие элементы управления реализуют поведение, определенное событие помечено как обработанное куда заменяется более интуитивным событием.</span><span class="sxs-lookup"><span data-stu-id="4aca4-138">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="4aca4-139">Как правило элемент управления только отметит событие ввода платформы как обработанное, если имеется целями разработки таким образом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-139">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="4aca4-140">В некоторых сценариях желаемого может быть способа обработки событий ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-140">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="4aca4-141">Это для этих сценариев, регистрации обработчиков с `handledEventsToo` как `true` подходит.</span><span class="sxs-lookup"><span data-stu-id="4aca4-141">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="4aca4-142">Но этого не следует делать это регулярно.</span><span class="sxs-lookup"><span data-stu-id="4aca4-142">But you should not do this routinely.</span></span> <span data-ttu-id="4aca4-143">Вызов обработчиков в ответ на все события, даже в случае обработки усложнит событий в приложении логики обработки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-143">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="4aca4-144">Снижение производительности может отображаться, если логика обработчика является существенным.</span><span class="sxs-lookup"><span data-stu-id="4aca4-144">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="4aca4-145">Необходимо зарезервировать использование присоединения обработчиков для уже обработанных событий для ситуаций, где были обнаружены во время разработки, некоторые элементы управления обработки событий, по-прежнему необходимо обработать с помощью приложения логики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-145">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="4aca4-146">Предотвращение классов сочетания элементов управления другим способом является использование события предварительного просмотра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-146">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="4aca4-147">Например если <xref:System.Windows.ContentElement.MouseLeftButtonDown> помечено как обработанное обработкой классов, можно добавить обработчики для <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> вместо этого.</span><span class="sxs-lookup"><span data-stu-id="4aca4-147">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="4aca4-148">Можно добавить один и тот же обработчик того же события несколько раз, не вызывая исключение.</span><span class="sxs-lookup"><span data-stu-id="4aca4-148">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="4aca4-149">Тем не менее обработчик вызывается несколько раз, когда событие обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-149">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="4aca4-150">Таким образом рассмотрим, как это поведение может иметь побочные эффекты, которые следует учесть при реализации обработчика.</span><span class="sxs-lookup"><span data-stu-id="4aca4-150">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="4aca4-151">Этот метод обычно используется для реализации метода доступа «add» для [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] шаблона доступа события пользовательских перенаправленных событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-151">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-152">В следующем примере реализуется обработчик, вызванную <xref:System.Windows.FrameworkElement.Initialized> событий на странице, которая присоединяет один из именованных элементов на странице с помощью определенных обработчик `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-152">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="4aca4-153">Этот обработчик будет вызываться, даже если другой элемент в маршруте совместно используемые данные события как обработанные до достижения обрабатывающего элемента в маршруте.</span><span class="sxs-lookup"><span data-stu-id="4aca4-153">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AddToEventRoute : System.Windows.EventRoute * System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.AddToEventRoute (route, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route"><span data-ttu-id="4aca4-154">Маршрут события, к которому добавляются обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-154">The event route that handlers are added to.</span></span></param>
        <param name="e"><span data-ttu-id="4aca4-155">Информация о событии, используемая для добавления обработчиков.</span><span class="sxs-lookup"><span data-stu-id="4aca4-155">The event data that is used to add the handlers.</span></span> <span data-ttu-id="4aca4-156">Данный метод использует свойство <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> аргументов для создания обработчиков.</span><span class="sxs-lookup"><span data-stu-id="4aca4-156">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span></span></param>
        <summary><span data-ttu-id="4aca4-157">Добавляет обработчики в указанный <see cref="T:System.Windows.EventRoute" /> для настоящего коллекции обработчиков событий <see cref="T:System.Windows.ContentElement" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-157">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-158">Используйте этот метод для элементов (независимо от того, является ли они реализуют <xref:System.Windows.IContentHost>) чтобы добавить обработчики для дочерних элементов узла <xref:System.Windows.EventRoute>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-158">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.ContentElement.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-159">Получает или задает значение, указывающее, может ли данный элемент использоваться как место назначения операции перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="4aca4-159">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span></span></summary>
        <value><span data-ttu-id="4aca4-160">Значение <see langword="true" />, если этот элемент можно использовать в качестве целевого объекта для операции перетаскивания; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-160"><see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-161">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-161">The default value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-162">Операции перетаскивания и вставки не включены по умолчанию и необходимо включить, задав намеренно <xref:System.Windows.ContentElement.AllowDrop%2A> для `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-162">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="4aca4-163">Кроме данной базовой настройки, и перетащите поведение зависит от способа реализации и не определяется <xref:System.Windows.ContentElement> или любого другого класса базовых элементов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-163">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="4aca4-164">Некоторые элементы управления, например, <xref:System.Windows.Controls.RichTextBox>, есть ли у поведение по умолчанию, но не <xref:System.Windows.ContentElement> производные классы имеют такие расширения функциональности.</span><span class="sxs-lookup"><span data-stu-id="4aca4-164">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="4aca4-165">Дополнительные сведения об операции перетаскивания см. в разделе [Drag and Drop Обзор](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-165">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="4aca4-166"><xref:System.Windows.FrameworkContentElement> переопределяет метаданные для этого свойства зависимостей в своей реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-166"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="4aca4-167">В частности <xref:System.Windows.FrameworkContentElement> обозначает, что это свойство позволяет наследование значения свойства (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> является `true` в метаданных).</span><span class="sxs-lookup"><span data-stu-id="4aca4-167">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="4aca4-168">Наследование значения свойства в данном контексте означает, что если существуют дочерние элементы, имеющие отсутствует значение для <xref:System.Windows.ContentElement.AllowDrop%2A> , присвоенное с помощью локальных значений или стилей, значение ближайшего родительского элемента с назначенным данным значением (опять же, либо в стилях, по умолчанию значения, или локальное значение), а затем значение из этого родительского элемента будет назначено все неназначенные дочерние элементы, системой свойств.</span><span class="sxs-lookup"><span data-stu-id="4aca4-168">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="4aca4-169">Это означает, что можно указать, следует ли разрешить выполнение операций перетаскивания в корневом элементе, а затем распространите значение ко всем <xref:System.Windows.FrameworkContentElement> дочерние элементы, не назначенные специально его значение `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-169">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-170">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-170">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-171">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-171">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="4aca4-172">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-172">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-173">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-173">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-174">В следующем примере задается <xref:System.Windows.ContentElement.AllowDrop%2A> в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="4aca4-174">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AllowDropProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AllowDropProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-175">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.AllowDrop" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-175">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4aca4-176">Применяет анимацию к указанному свойству зависимостей в этом элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-176">Applies an animation to a specified dependency property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="4aca4-177">Идентификатор анимируемого свойства.</span><span class="sxs-lookup"><span data-stu-id="4aca4-177">The identifier for the property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="4aca4-178">Таймер анимации, контролирующий и объявляющий анимацию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-178">The animation clock that controls and declares the animation.</span></span></param>
        <summary><span data-ttu-id="4aca4-179">Применяет анимацию к указанному свойству зависимостей в этом элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-179">Applies an animation to a specified dependency property on this element.</span></span> <span data-ttu-id="4aca4-180">Все существующие анимации останавливаются и заменяются новой анимацией.</span><span class="sxs-lookup"><span data-stu-id="4aca4-180">Any existing animations are stopped and replaced with the new animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-181">Чтобы удалить анимацию из свойства, укажите идентификатор для этого свойства, как `dp` и укажите `clock` как `null`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-181">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="4aca4-182">Это избавляет от анимации и анимированное свойство имеет значение к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="4aca4-182">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="4aca4-183">Тем не менее счетчик анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-183">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="4aca4-184">Любые другие анимации, привязанные к этому счетчику по-прежнему запуска.</span><span class="sxs-lookup"><span data-stu-id="4aca4-184">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="4aca4-185">Анимируемое свойство.</span><span class="sxs-lookup"><span data-stu-id="4aca4-185">The property to animate.</span></span></param>
        <param name="clock"><span data-ttu-id="4aca4-186">Таймер анимации, контролирующий и объявляющий анимацию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-186">The animation clock that controls and declares the animation.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="4aca4-187">Значение перечисления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-187">A value of the enumeration.</span></span> <span data-ttu-id="4aca4-188">Значение по умолчанию — <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />; это значение будет останавливать все существующие анимации и заменять их новой анимацией.</span><span class="sxs-lookup"><span data-stu-id="4aca4-188">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span></span></param>
        <summary><span data-ttu-id="4aca4-189">Применяет анимацию к заданному свойству зависимостей этого элемента с возможностью указать, что должно происходить, если у свойства уже имеется запущенная анимация.</span><span class="sxs-lookup"><span data-stu-id="4aca4-189">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-190">Чтобы удалить анимацию из свойства, укажите идентификатор для этого свойства, как `dp` и укажите `clock` как `null`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-190">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="4aca4-191">Это избавляет от анимации и анимированное свойство имеет значение к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="4aca4-191">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="4aca4-192">Тем не менее счетчик анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-192">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="4aca4-193">Любые другие анимации, привязанные к этому счетчику по-прежнему запуска.</span><span class="sxs-lookup"><span data-stu-id="4aca4-193">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCaptured : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-194">Получает значение, которое указывает, была ли хотя бы одна операция сенсорного ввода передана в данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-194">Gets a value that indicates whether at least one touch is captured to this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-195">Значение <see langword="true" />, если хотя бы одна операция сенсорного ввода получена данным элементом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-195"><see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-196">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-196">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesCapturedWithin : bool" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-197">Получает значение, указывающее, была ли хотя бы одна операция сенсорного ввода передана в данный элемент или в какой-либо из его дочерних элементов в визуальном дереве.</span><span class="sxs-lookup"><span data-stu-id="4aca4-197">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="4aca4-198">Значение <see langword="true" />, если хотя бы одна операция сенсорного ввода получена данным элементом или каким-либо из его дочерних элементов в визуальном дереве; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-198"><see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesCapturedWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-199">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-199">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesDirectlyOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-200">Получает значение, которое указывает, произошло ли хотя бы одно сенсорное нажатие данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-200">Gets a value that indicates whether at least one touch is pressed over this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-201">Значение <see langword="true" />, если произошло хотя бы одно сенсорное нажатие данного элемента; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-201"><see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-202">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-202">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.AreAnyTouchesOver : bool" Usage="System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-203">Получает значение, указывающее, произошло ли хотя бы одно сенсорное нажатие данного элемента или какого-либо из его дочерних элементов в визуальном дереве.</span><span class="sxs-lookup"><span data-stu-id="4aca4-203">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="4aca4-204">Значение <see langword="true" />, если произошло хотя бы одно сенсорное нажатие данного элемента или какого-либо из его дочерних элементов в визуальном дереве; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-204"><see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable AreAnyTouchesOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-205">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-205">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="4aca4-206">Запускает анимацию для указанного свойства данного элемента, имеющего анимацию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-206">Starts an animation for a specified animated property on this element.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="4aca4-207">Свойство для анимации, указанное как идентификатор свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-207">The property to animate, which is specified as a dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="4aca4-208">График для анимации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-208">The timeline of the animation to start.</span></span></param>
        <summary><span data-ttu-id="4aca4-209">Запускает анимацию для указанного свойства данного элемента, имеющего анимацию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-209">Starts an animation for a specified animated property on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-210">При проверке анимировано ли свойство, обратите внимание, что анимация начнет считаться анимации при отображении первый кадр не анимационные отправной точкой.</span><span class="sxs-lookup"><span data-stu-id="4aca4-210">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="4aca4-211">Если <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> для `animation` является `null`, любые текущие анимации будут удалены и текущее значение свойства будет сохранено.</span><span class="sxs-lookup"><span data-stu-id="4aca4-211">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="4aca4-212">Если весь `animation` значение `null`, все анимации будут удалены из свойства, и свойство возвращается к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="4aca4-212">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="4aca4-213">Тем не менее временной шкалы анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-213">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="4aca4-214">Любые другие анимации, назначенные эту временную шкалу продолжит запуска.</span><span class="sxs-lookup"><span data-stu-id="4aca4-214">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="contentElement.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="4aca4-215">Свойство для анимации, указанное как идентификатор свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-215">The property to animate, which is specified as the dependency property identifier.</span></span></param>
        <param name="animation"><span data-ttu-id="4aca4-216">График для анимации, которую следует применить.</span><span class="sxs-lookup"><span data-stu-id="4aca4-216">The timeline of the animation to be applied.</span></span></param>
        <param name="handoffBehavior"><span data-ttu-id="4aca4-217">Значение перечисления, которое указывает, как новая анимация должна взаимодействовать с любыми текущими анимациями, уже влияющими на значение свойства.</span><span class="sxs-lookup"><span data-stu-id="4aca4-217">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span></span></param>
        <summary><span data-ttu-id="4aca4-218">Запускает указанную анимацию для указанного анимированного свойства зависимостей этого элемента, с возможностью указания действий, которые следует предпринять при уже существующей анимации для данного свойства.</span><span class="sxs-lookup"><span data-stu-id="4aca4-218">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-219">При проверке анимировано ли свойство, обратите внимание, что анимация начнет считаться анимации при отображении первый кадр не анимационные отправной точкой.</span><span class="sxs-lookup"><span data-stu-id="4aca4-219">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="4aca4-220">Если <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> для `animation` является `null`, любые текущие анимации будут удалены и текущее значение свойства будет сохранено.</span><span class="sxs-lookup"><span data-stu-id="4aca4-220">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="4aca4-221">Если весь `animation` значение `null`, все анимации будут удалены из свойства, и свойство возвращается к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="4aca4-221">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="4aca4-222">Тем не менее временной шкалы анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-222">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="4aca4-223">Любые другие анимации, назначенные эту временную шкалу продолжит запуска.</span><span class="sxs-lookup"><span data-stu-id="4aca4-223">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberSignature Language="F#" Value="abstract member CaptureMouse : unit -&gt; bool&#xA;override this.CaptureMouse : unit -&gt; bool" Usage="contentElement.CaptureMouse " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-224">Пытается принудительно захватить мышь данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-224">Attempts to force capture of the mouse to this element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-225">Значение <see langword="true" />, если мышь успешно захвачена, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-225"><see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-226">Для захвата необходимо включить элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-226">To be captured, an element must be enabled.</span></span> <span data-ttu-id="4aca4-227">Проверьте ли <xref:System.Windows.ContentElement.IsEnabled%2A> — `true` перед вызовом метода <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-227">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="4aca4-228">Если вызов <xref:System.Windows.ContentElement.CaptureMouse%2A> возвращает `true`, затем <xref:System.Windows.ContentElement.IsMouseCaptured%2A> также `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-228">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="4aca4-229">Если вызов <xref:System.Windows.ContentElement.CaptureMouse%2A> возвращает `true`, то <xref:System.Windows.ContentElement.GotMouseCapture> и <xref:System.Windows.ContentElement.IsMouseCapturedChanged> событий, с помощью <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> событий данными в отчетах как элемент где <xref:System.Windows.ContentElement.CaptureMouse%2A> вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="4aca4-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="4aca4-230">При попытке захвата, возможен конфликт с существующей записью — особенно с помощью относящимися к и перетаскивать мышью.</span><span class="sxs-lookup"><span data-stu-id="4aca4-230">If you force capture, you might interfere with existing captures - especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="4aca4-231">Чтобы очистить захват мыши из всех элементов, вызовите <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> с `element` указан как параметр `null`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-231">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-232">В следующем примере захвате мыши или отпускает захват, в зависимости от уже записали мыши элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-232">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="4aca4-233">Обратите внимание, что в данном примере приводится потенциального записи целевой элемент для <xref:System.Windows.IInputElement> интерфейс и таким образом исходного вызова <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="4aca4-233">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="4aca4-234">Приведение к <xref:System.Windows.IInputElement> методика полезна, если вы не уверены, является ли элемент требуется, чтобы захвата мыши <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-234">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="4aca4-235">Приведение интерфейса и метода интерфейса вызовов затем вызовы соответствующую реализацию определенного типа CaptureMouse внутренне без необходимости пробную версию на приведение либо <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-235">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="4aca4-236">Данная техника работает для других элементов, <xref:System.Windows.IInputElement> определяет, к примеру многие события ввода и другие методы ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-236">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberSignature Language="F#" Value="abstract member CaptureStylus : unit -&gt; bool&#xA;override this.CaptureStylus : unit -&gt; bool" Usage="contentElement.CaptureStylus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-237">Пытается принудительно захватить перо данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-237">Attempts to force capture of the stylus to this element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-238">Значение <see langword="true" />, если перо успешно захвачена, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-238"><see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-239">Реализация по умолчанию, в зависимости от в базовое устройство пера по умолчанию всегда возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-239">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="4aca4-240">Тем не менее при расширении устройств ввода, которые обеспечивают реализацию устройств для системы ввода, существует возможность создания системы с альтернативной реализацией перьевого устройства, могут возвращать разные результаты.</span><span class="sxs-lookup"><span data-stu-id="4aca4-240">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="4aca4-241">При захвате пера, он получает ввод от пера, даже если перо находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-241">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="4aca4-242">Перо обычно захватывается только во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-242">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="4aca4-243">Вызов этого метода вызывает статический базовая <xref:System.Windows.Input.Stylus> метод <xref:System.Windows.Input.Stylus.Capture%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-243">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="4aca4-244">Поведение самого захвата реализуется путем реализации устройства активное перо.</span><span class="sxs-lookup"><span data-stu-id="4aca4-244">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="4aca4-245">Для захвата необходимо включить элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-245">To be captured, an element must be enabled.</span></span> <span data-ttu-id="4aca4-246">Проверьте ли <xref:System.Windows.ContentElement.IsEnabled%2A> — `true` возвращают перед вызовом метода <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-246">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="4aca4-247">Если вызов <xref:System.Windows.ContentElement.CaptureStylus%2A> возвращает `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> также `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-247">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.CaptureTouch : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.CaptureTouch touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="4aca4-248">Захватываемое устройство.</span><span class="sxs-lookup"><span data-stu-id="4aca4-248">The device to capture.</span></span></param>
        <summary><span data-ttu-id="4aca4-249">Предпринимает попытку принудительного получения операции сенсорного ввода данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-249">Attempts to force capture of a touch to this element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-250">Значение <see langword="true" />, если указанная операция сенсорного ввода была получена данным элементом; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-250"><see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> Возвращает `false` Если <xref:System.Windows.Input.TouchDevice> записывается в настоящее время к другому элементу.</span><span class="sxs-lookup"><span data-stu-id="4aca4-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="4aca4-252">Если <xref:System.Windows.ContentElement.CaptureTouch%2A> возвращает `true`, а затем <xref:System.Windows.ContentElement.GotTouchCapture> события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-252">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="4aca4-253">Чтобы освободить записи из одного касания из этого элемента, используйте <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> метод и указать Освобождаемое устройство сенсорного ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-253">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="4aca4-254">Чтобы освободить все штрихи из этого элемента, используйте <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="4aca4-254">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aca4-255"><paramref name="touchDevice" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-255"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandBindings : System.Windows.Input.CommandBindingCollection" Usage="System.Windows.ContentElement.CommandBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-256">Возвращает коллекцию объектов <see cref="T:System.Windows.Input.CommandBinding" />, сопоставленных этому элементу.</span><span class="sxs-lookup"><span data-stu-id="4aca4-256">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-257">Коллекция всех объектов <see cref="T:System.Windows.Input.CommandBinding" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-257">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-258">Объект <xref:System.Windows.Input.CommandBinding> включает обработку команды для определенной команды для данного элемента и объявляет компоновку между командой, события и обработчики, присоединенные данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-258">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="4aca4-259">Другой способ заполнения <xref:System.Windows.ContentElement.CommandBindings%2A> коллекции заключается в использовании <xref:System.Windows.Input.CommandManager> методы программным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-259">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="4aca4-260">Использование элемента свойства XAML</span><span class="sxs-lookup"><span data-stu-id="4aca4-260">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="4aca4-261">Значения XAML</span><span class="sxs-lookup"><span data-stu-id="4aca4-261">XAML Values</span></span>  
 <span data-ttu-id="4aca4-262">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="4aca4-262">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="4aca4-263">Один или несколько <xref:System.Windows.Input.CommandBinding> элементов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-263">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="4aca4-264">Каждый из них должен иметь <xref:System.Windows.Input.CommandBinding.Command%2A> значение атрибута известной командой, а атрибуты для <xref:System.Windows.Input.CommandBinding.CanExecute> и <xref:System.Windows.Input.CommandBinding.Executed> реализации обработчика.</span><span class="sxs-lookup"><span data-stu-id="4aca4-264">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="4aca4-265">Дополнительные сведения см. в разделе <xref:System.Windows.Input.CommandBinding>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-265">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.DragEventHandler " Usage="member this.DragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-266">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-266">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-267">Это событие создает псевдоним для <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-267">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-268">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.DragEnter> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-268">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-269">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-270">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-270">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="4aca4-271">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-271">Routing strategy</span></span>|<span data-ttu-id="4aca4-272">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-272">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-273">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-273">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-274">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewDragEnter>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-274">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="4aca4-275">Переопределить <xref:System.Windows.ContentElement.OnDragEnter%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-275">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-276">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.DragEnter" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-276">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-277">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-278">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-279">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-280">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-281">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.DragEventHandler " Usage="member this.DragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-282">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-282">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-283">Это событие создает псевдоним для <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-283">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-284">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.DragLeave> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-284">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-285">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-285">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-286">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-286">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="4aca4-287">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-287">Routing strategy</span></span>|<span data-ttu-id="4aca4-288">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-288">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-289">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-289">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-290">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.DragDrop.PreviewDragLeave>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-290">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="4aca4-291">Переопределить <xref:System.Windows.ContentElement.OnDragLeave%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-291">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-292">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.DragLeave" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-292">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-293">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-293">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-294">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-294">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-295">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-295">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-296">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-296">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-297">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-297">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.DragEventHandler " Usage="member this.DragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-298">Происходит, когда подсистема ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве потенциальной цели данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-298">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-299">Это событие происходит, даже если источник перетаскивания находится в границах элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-299">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="4aca4-300">Если перетаскивание начинается за пределами границ, а затем перемещается, это событие также возникает, а также <xref:System.Windows.ContentElement.DragEnter> и связанные события предварительного просмотра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-300">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="4aca4-301">Это событие создает псевдоним для <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-301">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-302">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.DragOver> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-302">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-303">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-303">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-304">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-304">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="4aca4-305">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-305">Routing strategy</span></span>|<span data-ttu-id="4aca4-306">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-306">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-307">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-307">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-308">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.DragDrop.PreviewDragOver>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-308">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="4aca4-309">Переопределить <xref:System.Windows.ContentElement.OnDragOver%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-309">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-310">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.DragOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-310">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-311">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-311">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-312">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-312">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-313">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-313">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-314">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-314">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-315">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-315">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberSignature Language="F#" Value="member this.Drop : System.Windows.DragEventHandler " Usage="member this.Drop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-316">Происходит, когда система ввода сообщает о базовом событии удаления с этим элементом в качестве цели удаления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-316">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-317">Это событие создает псевдоним для <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-317">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-318">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.Drop> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-318">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-319">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-319">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-320">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-320">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="4aca4-321">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-321">Routing strategy</span></span>|<span data-ttu-id="4aca4-322">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-322">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-323">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-323">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-324">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewDrop>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-324">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="4aca4-325">Переопределить <xref:System.Windows.ContentElement.OnDrop%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-325">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable DropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.DropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-326">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.Drop" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-326">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-327">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-327">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-328">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-328">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-329">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-329">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-330">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-330">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-331">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-331">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberSignature Language="F#" Value="abstract member Focus : unit -&gt; bool&#xA;override this.Focus : unit -&gt; bool" Usage="contentElement.Focus " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-332">Попытка задать фокус для данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-332">Attempts to set focus to this element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-333"><see langword="true" /> если элемент может получить клавиатурный фокус; <see langword="false" /> если в результате вызова данного метода элемент фокус не получил.</span><span class="sxs-lookup"><span data-stu-id="4aca4-333"><see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-334">Чтобы иметь возможность получать фокус, <xref:System.Windows.ContentElement.Focusable%2A> и <xref:System.Windows.ContentElement.IsEnabled%2A> должны быть `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-334">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="4aca4-335">Обратите внимание, что почти все <xref:System.Windows.ContentElement> производные классы не являются <xref:System.Windows.ContentElement.Focusable%2A> по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-335">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="4aca4-336">Даже если элемент является обработка событий, способному получать фокус и включена, в составе определенного дерева, (например, для составного элемента управления) может отвечать на события предварительного просмотра фокус, не позволяя фокус, таким образом этот метод вернет `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-336">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="4aca4-337">Фокус в целом регулируется два разных понятия: фокус клавиатуры и логический фокус, которые не всегда совпадают.</span><span class="sxs-lookup"><span data-stu-id="4aca4-337">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="4aca4-338">Этот метод устанавливает логический фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-338">This method sets the logical focus.</span></span> <span data-ttu-id="4aca4-339">Имеется программный способ задать фокус клавиатуры; фокус клавиатуры, определяется ввод данных пользователем.</span><span class="sxs-lookup"><span data-stu-id="4aca4-339">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="4aca4-340">Дополнительные сведения см. в разделе [Общие сведения о фокусе](~/docs/framework/wpf/advanced/focus-overview.md) и [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-340">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="4aca4-341">Если вызов <xref:System.Windows.ContentElement.Focus%2A> возвращает `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> и <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> также `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-341">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="4aca4-342">Если связанные свойства еще не сделали `true`, при вызове <xref:System.Windows.ContentElement.Focus%2A>, один или несколько из следующих событий вызываются в следующем порядке: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (источник — новый целевой объект фокус), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (источник — новый целевой объект фокус).</span><span class="sxs-lookup"><span data-stu-id="4aca4-342">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-343">В следующем примере обработчик событий загрузки страницы, обнаруживает указанный абзац в документе и устанавливает фокус на него.</span><span class="sxs-lookup"><span data-stu-id="4aca4-343">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="4aca4-344">Абзацы не получают фокус по умолчанию. данному параграфу был применен стиль (не показан), в котором использовался стиль <xref:System.Windows.Setter> для упрощения, способному получать фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-344">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Focusable : bool with get, set" Usage="System.Windows.ContentElement.Focusable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-345">Получение или установка значения, определяющего возможность получения фокуса элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-345">Gets or sets a value that indicates whether the element can receive focus.</span></span></summary>
        <value><span data-ttu-id="4aca4-346">Значение <see langword="true" />, если данный элемент может иметь фокус; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-346"><see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span></span> <span data-ttu-id="4aca4-347">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-347">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-348">Только элемент с фокусом получающий ввод с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-348">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="4aca4-349">Определенные производные классы могут переопределить метаданные для этого свойства зависимостей, таким образом, способному получать фокус по умолчанию производного класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-349">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="4aca4-350">Если наследуемые <xref:System.Windows.Documents.Hyperlink> или его производных классов <xref:System.Windows.Documents.Hyperlink> переопределяет метаданные для этого свойства зависимостей и переопределяет значение по умолчанию это свойство имело `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-350">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-351">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-351">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-352">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-352">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="4aca4-353">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-353">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-354">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-354">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-355">В следующем примере создается стиль, который делает <xref:System.Windows.Documents.Paragraph> по умолчанию, способному получать фокус и присваивает ему визуальное поведение, при получении фокуса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-355">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-356">При наследовании от <see cref="T:System.Windows.ContentElement" />, следует выбрать элемент должен иметь фокус, так как по умолчанию он не будет, способному получать фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-356">When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable.</span></span> <span data-ttu-id="4aca4-357">Если требуется, чтобы элемент должен иметь возможность получать фокус, переопределите метаданные для этого свойства в статический конструктора производного класса следующим образом:</span><span class="sxs-lookup"><span data-stu-id="4aca4-357">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span></span> 
<span data-ttu-id="4aca4-358">[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)] [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]</span><span class="sxs-lookup"><span data-stu-id="4aca4-358">[!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)] [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]</span></span> 
<span data-ttu-id="4aca4-359">где <paramref name="myElement" /> — это имя класса типа, который вы переопределяете значение метаданных.</span><span class="sxs-lookup"><span data-stu-id="4aca4-359">where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</span></span></para></block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberSignature Language="F#" Value="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.FocusableChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-360">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.Focusable" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-360">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-361">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-361">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable FocusableProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.FocusableProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-362">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.Focusable" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-362">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="contentElement.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp"><span data-ttu-id="4aca4-363">Проверяемое свойство зависимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-363">The.dependency property to check.</span></span></param>
        <summary><span data-ttu-id="4aca4-364">Возвращает значение базового свойства для указанного свойства данного элемента без учета возможного анимированного значения из запущенной или остановленной анимации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-364">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span></span></summary>
        <returns><span data-ttu-id="4aca4-365">Значение свойства, как если бы анимации не присоединялись к указанному свойству зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-365">The property value as if no animations are attached to the specified dependency property.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-366">Если бы анимации не присоединялись к свойству, а затем <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> возвращаемое значение всегда равно идентичен <xref:System.Windows.DependencyObject.GetValue%2A> возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="4aca4-366">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="4aca4-367">При возникновении анимированные, затем все возможные производные значения, включая начальные и остановки, игнорируются, и значение свойства определяется основываясь на всех других возможных входных значений.</span><span class="sxs-lookup"><span data-stu-id="4aca4-367">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="4aca4-368">Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-368">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberSignature Language="F#" Value="abstract member GetUIParentCore : unit -&gt; System.Windows.DependencyObject&#xA;override this.GetUIParentCore : unit -&gt; System.Windows.DependencyObject" Usage="contentElement.GetUIParentCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-369">При переопределении в производном классе возвращает альтернативный родительский элемент [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] при условии отсутствия видимого родительского элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-369">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span></span></summary>
        <returns><span data-ttu-id="4aca4-370">Объект, если реализация производного класса сообщает об альтернативном родительском подключении.</span><span class="sxs-lookup"><span data-stu-id="4aca4-370">An object, if implementation of a derived class has an alternate parent connection to report.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-371">Реализация виртуального по умолчанию этот метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-371">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="4aca4-372"><xref:System.Windows.FrameworkContentElement> предоставляет практической реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-372"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="4aca4-373">Альтернативные родительские, используемых для маршрутизации событий, в случаях, когда элемент создает альтернативную родительскую структуру, чтобы его события маршрутизируются способом, который отличается от стандартного шаблона маршрутизации вверх по визуальному дереву родительскому элементу, или вниз Предварительный просмотр стратегия маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-373">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-374">Происходит, когда подсистема ввода сообщает о соответствующем событии перетаскивания, в котором участвует данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-374">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-375"><xref:System.Windows.ContentElement.GiveFeedback> Событие позволяет источнику события перетаскивания изменять внешний вид указателя мыши, чтобы обеспечить пользователю визуальную обратную связь во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-375">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="4aca4-376">Визуальная обратная связь подкрепляет, что операция перетаскивания и вставки находится в процессе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-376">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="4aca4-377">Это событие создает псевдоним для <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.GiveFeedback> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-377">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-378">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GiveFeedback> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-378">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-379">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-379">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-380">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-380">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="4aca4-381">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-381">Routing strategy</span></span>|<span data-ttu-id="4aca4-382">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-382">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-383">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-383">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="4aca4-384">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-384">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="4aca4-385">Переопределить <xref:System.Windows.ContentElement.OnGiveFeedback%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-385">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-386">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GiveFeedback" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-386">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-387">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-387">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-388">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-388">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-389">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-389">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-390">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-390">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-391">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-391">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.RoutedEventHandler " Usage="member this.GotFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-392">Происходит при получении данным элементом логического фокуса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-392">Occurs when this element gets logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-393">Логический фокус отличается от фокус клавиатуры, если он является результатом вызова метода, в в другой области существует предыдущий фокус клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-393">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="4aca4-394">В этом случае клавиатурный фокус остается там, где это и элемент где <xref:System.Windows.ContentElement.Focus%2A> вызывается метод по-прежнему получает логический фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-394">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="4aca4-395">Более точная Интерпретация значений свойств этого события является он вызывается, когда значение <xref:System.Windows.ContentElement.IsFocused%2A> любого элемента в маршруте меняется с `false` для `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-395">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="4aca4-396">Вследствие этого события восходящей маршрутизации, элемент, получающий фокус может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-396">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-397">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, полученная фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-397">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-398">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-398">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-399">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-399">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="4aca4-400">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-400">Routing strategy</span></span>|<span data-ttu-id="4aca4-401">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-401">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-402">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-402">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="4aca4-403">Нет соответствующего события нисходящей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-403">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-404">Переопределить <xref:System.Windows.ContentElement.OnGotFocus%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-404">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-405">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-405">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-406">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-406">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-407">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-407">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-408">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-408">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-409">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-409">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-410">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-410">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.GotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-411">Происходит при получении данным элементом фокуса ввода с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-411">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-412"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> — Аналогично событие, которое отслеживает изменения состояния в свойство, которое поддерживает состояние фокуса для элемента; <xref:System.Windows.ContentElement.GotKeyboardFocus> события во многих случаях же.</span><span class="sxs-lookup"><span data-stu-id="4aca4-412"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="4aca4-413">Вследствие этого события восходящей маршрутизации, элемент, имеющий фокус может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-413">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-414">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, имеющий фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-414">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="4aca4-415">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.GotKeyboardFocus> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-415">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-416">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GotKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-416">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-417">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-417">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-418">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-418">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="4aca4-419">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-419">Routing strategy</span></span>|<span data-ttu-id="4aca4-420">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-420">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-421">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-421">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="4aca4-422">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-422">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="4aca4-423">Переопределить <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-423">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-424">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-424">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-425">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-425">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-426">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-426">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-427">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-427">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-428">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-428">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-429">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-429">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.GotMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-430">Происходит при захвате мыши данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-430">Occurs when this element captures the mouse.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-431">При захвате мыши, он получает ввод от мыши, даже если указатель мыши находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-431">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="4aca4-432">Мышь обычно захватывается только во время операции перетаскивания и вставки и остается захваченной, пока не произойдет действие операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-432">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="4aca4-433">Вследствие этого события восходящей маршрутизации, элемент, захвативший может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-433">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-434">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> событий системы отслеживания измененных данных, чтобы определить фактический элемент, имеющий мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-434">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="4aca4-435">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.GotMouseCapture> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-435">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-436">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GotMouseCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-436">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-437">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-437">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-438">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-438">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="4aca4-439">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-439">Routing strategy</span></span>|<span data-ttu-id="4aca4-440">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-440">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-441">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-441">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="4aca4-442">Имеется соответствующее событие не определено туннелирования.</span><span class="sxs-lookup"><span data-stu-id="4aca4-442">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-443">Переопределить <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-443">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-444">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotMouseCapture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-444">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-445">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-445">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-446">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-446">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-447">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-447">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-448">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-448">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-449">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-449">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.GotStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-450">Происходит при захвате пера данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-450">Occurs when this element captures the stylus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-451">При захвате пера, он получает ввод от пера, даже если указатель находится вне границ.</span><span class="sxs-lookup"><span data-stu-id="4aca4-451">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="4aca4-452">Перо обычно захватывается только во время операции перетаскивания и вставки и сохраняет захват, пока не произойдет действие операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-452">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="4aca4-453">Вследствие этого события восходящей маршрутизации, элемент, захвативший может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-453">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-454">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, захвативший.</span><span class="sxs-lookup"><span data-stu-id="4aca4-454">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="4aca4-455">Это событие создает псевдоним для присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.GotStylusCapture> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-455">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-456">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GotStylusCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-456">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-457">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-457">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-458">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-458">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="4aca4-459">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-459">Routing strategy</span></span>|<span data-ttu-id="4aca4-460">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-460">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-461">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-461">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-462">Имеется соответствующее событие не определено туннелирования.</span><span class="sxs-lookup"><span data-stu-id="4aca4-462">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-463">Переопределить <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-463">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-464">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotStylusCapture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-464">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-465">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-465">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-466">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-466">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-467">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-467">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-468">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-468">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-469">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-469">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.GotTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.GotTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-470">Происходит при получении данным элементом операции сенсорного ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-470">Occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-471">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-471">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-472">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-472">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="4aca4-473">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-473">Routing strategy</span></span>|<span data-ttu-id="4aca4-474">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-474">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-475">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-475">Delegate</span></span>|<span data-ttu-id="4aca4-476"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-476"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-477">Переопределить <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-477">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable GotTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-478">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotTouchCapture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-478">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-479">Возвращает значение, указывающее, имеет ли экземпляр анимированные свойства.</span><span class="sxs-lookup"><span data-stu-id="4aca4-479">Gets a value that indicates whether this element has any animated properties.</span></span></summary>
        <value><span data-ttu-id="4aca4-480"><see langword="true" />, если элемент имеет анимированные свойства; иначе, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-480"><see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-481">Это свойство возвращает `true` для постоянных (без часов, всегда запущенной) анимации или анимации, которые имеют определенного графика.</span><span class="sxs-lookup"><span data-stu-id="4aca4-481">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.InputBindings : System.Windows.Input.InputBindingCollection" Usage="System.Windows.ContentElement.InputBindings" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-482">Возвращает коллекцию привязок ввода, используемых этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-482">Gets the collection of input bindings that are associated with this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-483">Коллекция привязок ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-483">The collection of input bindings.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-484">Входные привязки поддерживают привязку команды, чтобы устройства ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-484">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="4aca4-485">Например <xref:System.Windows.Input.MouseBinding> реализует входных привязок, которые содержат свойства, относящиеся к мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-485">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="4aca4-486">Коллекция привязок ввода включает как привязки ввода, относящиеся к типу, а также привязки ввода, объявленные в экземпляре.</span><span class="sxs-lookup"><span data-stu-id="4aca4-486">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="4aca4-487">Связанное свойство <xref:System.Windows.ContentElement.CommandBindings%2A>, поддерживает коллекцию привязок команд.</span><span class="sxs-lookup"><span data-stu-id="4aca4-487">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="4aca4-488">Эти привязки отличаются от привязок ввода, представляющие следующий уровень вниз обработки команд - действий, которые связаны с известных командами и обработчиками данного класса, для них.</span><span class="sxs-lookup"><span data-stu-id="4aca4-488">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="4aca4-489">Использование элемента свойства XAML</span><span class="sxs-lookup"><span data-stu-id="4aca4-489">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="4aca4-490">Значения XAML</span><span class="sxs-lookup"><span data-stu-id="4aca4-490">XAML Values</span></span>  
 <span data-ttu-id="4aca4-491">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="4aca4-491">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="4aca4-492">Один или несколько <xref:System.Windows.Input.InputBinding> элементов (обычно <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding> производные классы).</span><span class="sxs-lookup"><span data-stu-id="4aca4-492">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="4aca4-493">Каждый из них должен иметь <xref:System.Windows.Input.InputBinding.Command%2A> и <xref:System.Windows.Input.InputBinding.Gesture%2A> набором атрибутов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-493">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabled : bool with get, set" Usage="System.Windows.ContentElement.IsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-494">Получает или задает значение, определяющее, активен ли этот элемент в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="4aca4-494">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span></span></summary>
        <value><span data-ttu-id="4aca4-495">Значение <see langword="true" />, если элемент включен; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-495"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-496">Значение по умолчанию — <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-496">The default value is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-497">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-497">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-498">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-498">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="4aca4-499">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-499">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-500">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-500">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-501">В следующем примере создается стиль, который включает в себя метод задания свойства, которое позволяет получить другое поведение visual при <xref:System.Windows.Documents.Hyperlink> присваивается <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-501">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberSignature Language="F#" Value="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsEnabledChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-502">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsEnabled" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-502">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-503">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-503">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnabledCore : bool" Usage="System.Windows.ContentElement.IsEnabledCore" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-504">Возвращает значение, которое становится возвращаемым значением свойства <see cref="P:System.Windows.ContentElement.IsEnabled" /> в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-504">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span></span></summary>
        <value><span data-ttu-id="4aca4-505">Значение <see langword="true" />, если элемент включен; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-505"><see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-506">Реализация по умолчанию этого свойства кэширует значение, а также вычисляет, включен ли родительский элемент данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-506">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span></span> <span data-ttu-id="4aca4-507">(Если родительский не включена, дочерний элемент может быть успешно активирован в practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) Если вы решили переопределить эту реализацию, убедитесь, что вы вызывать базовую реализацию для сохранения этого поведения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-507">(If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsEnabledProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsEnabledProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-508">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsEnabled" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-508">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFocused : bool" Usage="System.Windows.ContentElement.IsFocused" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-509">Получает значение, определяющее, имеет ли элемент логический фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-509">Gets a value that determines whether this element has logical focus.</span></span></summary>
        <value><span data-ttu-id="4aca4-510">Значение <see langword="true" />, если элемент имеет логический фокус; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-510"><see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-511">Логический фокус могут отличаться от фокус клавиатуры, если приложение имеет несколько разделений фокус, например между содержимое меню и остальной частью приложения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-511">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="4aca4-512">В этом случае фокус клавиатуры можно только на одном элементе пользовательского интерфейса приложения, тем не менее, некоторые элементы в других разделах фокуса может по-прежнему сохраняет логический фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-512">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="4aca4-513">Дополнительные сведения о логическом фокусе см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md) и [Общие сведения о фокусе](~/docs/framework/wpf/advanced/focus-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-513">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-514">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-514">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-515">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-515">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="4aca4-516">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-516">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-517">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-517">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-518">В следующем примере создается стиль, который делает <xref:System.Windows.Documents.Paragraph> по умолчанию, способному получать фокус и присваивает ему визуальное поведение, при получении фокуса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-518">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-519">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsFocused" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-519">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInputMethodEnabled : bool" Usage="System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-520">Возвращает значение, определяющее, активирована ли система метода ввода, как [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], для обработки ввода для данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-520">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-521">Значение <see langword="true" />, если метод ввода активен; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-521"><see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-522">Значение по умолчанию базового присоединенного свойства — <see langword="true" />, однако это значение влияет состояние методов ввода во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-522">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-523">Это свойство возвращает значение, которое возвращается путем присоединенного свойства <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> для в настоящий момент разрешенные методы ввода (клавиатуры, речи и других устройств ввода).</span><span class="sxs-lookup"><span data-stu-id="4aca4-523">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocused : bool" Usage="System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-524">Возвращает значение, указывающее, имеет ли элемент фокус ввода от клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-524">Gets a value that indicates whether this element has keyboard focus.</span></span></summary>
        <value><span data-ttu-id="4aca4-525">Значение <see langword="true" />, если элемент имеет фокус клавиатуры; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-525"><see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-526">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-526">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-527">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-527">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-528">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-528">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="4aca4-529">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-529">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-530">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-530">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-531">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-531">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-532">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-532">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-533">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-533">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithin : bool" Usage="System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-534">Возвращает значение, определяющее, находится ли клавиатурный фокус на элементе, или его дочерних элементах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-534">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span></span></summary>
        <value><span data-ttu-id="4aca4-535">Значение <see langword="true" />, если фокус клавиатуры находится в элементе или в его дочерних элементах; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-535"><see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-536">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-536">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-537">Изменение значения этого свойства обычно вызывают <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> событие, если производный класс переопределил <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> для подавления событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-537">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="4aca4-538">Это свойство не задано непосредственно, но можно установить фокус на элемент, вызвав <xref:System.Windows.ContentElement.Focus%2A>, или сделав <xref:System.Windows.ContentElement.MoveFocus%2A> запроса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-538">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="4aca4-539">Одно из этих вызовов метода может изменить значение этого свойства.</span><span class="sxs-lookup"><span data-stu-id="4aca4-539">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-540">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-540">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-541">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-541">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="4aca4-542">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-542">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-543">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-543">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-544">Происходит при изменении значения свойства <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-544">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-545">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-545">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsKeyboardFocusWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-546">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-546">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptured : bool" Usage="System.Windows.ContentElement.IsMouseCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-547">Возвращает значение, определяющее, захвачена ли мышь данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-547">Gets a value that indicates whether the mouse is captured by this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-548">Значение <see langword="true" />, если элемент имеет захват мыши; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-548"><see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-549">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-549">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-550">Состояние захвата мыши связана с внутрипроцессные операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-550">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-551">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-551">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-552">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-552">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="4aca4-553">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-553">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-554">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-554">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-555">В следующем примере производится состояние захвата мыши включить или отключить зависимости ли мышь захвачена уже в элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-555">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-556">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-556">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-557">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-557">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-558">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseCaptured" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-558">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithin : bool" Usage="System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-559">Получает значение, определяющее, удерживается ли захват мыши данным элементом или дочерними элементами в его дереве элементов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-559">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span></span></summary>
        <value><span data-ttu-id="4aca4-560">Значение <see langword="true" />, если элемент или содержащийся в нем элемент получил захват мыши; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-560"><see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-561">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-561">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-562">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-562">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-563">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-563">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="4aca4-564">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-564">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-565">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-565">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-566">Происходит при изменении значения поля <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-566">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-567">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-567">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-568">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-568">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOver : bool" Usage="System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-569">Возвращает значение, указывающее, соответствует ли позиция указателя мыши результатам проверки нажатия, при которой учитывается компоновка элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-569">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><span data-ttu-id="4aca4-570">Значение <see langword="true" />, если указатель мыши находится над тем же элементом, что и результат проверки нажатия; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-570"><see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-571">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-571">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-572">В отличие от <xref:System.Windows.ContentElement.IsMouseOver%2A>, это свойство имеет только `true` если указатель мыши находится над элементом литерала -, как и для проверки нажатия.</span><span class="sxs-lookup"><span data-stu-id="4aca4-572">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element - as it is for a hit test.</span></span> <span data-ttu-id="4aca4-573">Если указатель мыши находится над дочерним элементом, в частности по элементам, которые являются частью глубокого шаблона элемента и его композиции, это свойство будет иметь `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-573">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="4aca4-574">Если вы знаете, как элемент управления составных (например, это свойство используется в пользовательский шаблон элемента управления для элемента управления, который определяется), это свойство может возвращать непредвиденные результаты.</span><span class="sxs-lookup"><span data-stu-id="4aca4-574">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="4aca4-575">Для большинства сценариев, где вы не создаете элементы управления, используйте <xref:System.Windows.ContentElement.IsMouseOver%2A> вместо этого.</span><span class="sxs-lookup"><span data-stu-id="4aca4-575">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="4aca4-576">Если мышь захвачена этот элемент, и это свойство имеет `true` во время захвата, это свойство будет продолжать возвращать `true` пока захват мыши не будет потерян и указатель не выйдет за границы элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-576">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-577">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-577">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-578">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-578">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="4aca4-579">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-579">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-580">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-580">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-581">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-581">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-582">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-582">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-583">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-583">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMouseOver : bool" Usage="System.Windows.ContentElement.IsMouseOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-584">Возвращает значение, определяющее, находится ли указатель мыши на элементе (включая видимые дочерние элементы и композицию элемента управления).</span><span class="sxs-lookup"><span data-stu-id="4aca4-584">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span></span></summary>
        <value><span data-ttu-id="4aca4-585">Значение <see langword="true" />, если указатель мыши находится над элементом или его дочерними элементами; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-585"><see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-586">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-586">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-587">Несмотря на то, что аналогично событие «IsMouseOverChanged» не существует, выполните несколько аналогичных событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-587">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="4aca4-588">Например, можно использовать <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, и <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-588">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="4aca4-589">Если этот элемент захват мыши, это свойство остается `true` пока захват мыши теряется и указатель мыши покидает границы элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-589">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-590">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-590">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-591">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-591">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="4aca4-592">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-592">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-593">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-593">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-594">В следующем примере создается стиль, который включает в себя метод задания свойства, которое позволяет получить другое поведение visual при <xref:System.Windows.Documents.Hyperlink> отчеты <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-594">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsMouseOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-595">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-595">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptured : bool" Usage="System.Windows.ContentElement.IsStylusCaptured" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-596">Возвращает значение, определяющее, захвачено ли перо данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-596">Gets a value that indicates whether the stylus is captured to this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-597">Значение <see langword="true" />, если элемент имеет захват пера; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-597"><see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-598">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-598">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-599">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-599">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-600">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-600">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-601">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-601">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-602">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-602">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="4aca4-603">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-603">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-604">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-604">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-605">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-605">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-606">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-606">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCapturedProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-607">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusCaptured" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-607">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithin : bool" Usage="System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-608">Возвращает значение, определяющее, захвачено ли перо этим элементом, включая его дочерние элементы и композицию элемента управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-608">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span></span></summary>
        <value><span data-ttu-id="4aca4-609"><see langword="true" /> если перо захвачено данным элементом; иначе, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-609"><see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-610">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-610">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-611">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-611">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-612">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-612">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-613">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-613">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="4aca4-614">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-614">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-615">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-615">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-616">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-616">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-617">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-617">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusCaptureWithinProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-618">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-618">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOver : bool" Usage="System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-619">Возвращает значение, указывающее, соответствует ли позиция пера результатам проверки нажатия, при которой учитывается компоновка элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-619">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span></span></summary>
        <value><span data-ttu-id="4aca4-620"><see langword="true" /> если проверка подтверждает результаты проверки нажатия; иначе, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-620"><see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-621">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-621">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-622">В отличие от <xref:System.Windows.ContentElement.IsStylusOver%2A>, это свойство имеет только `true` если перо находится над элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-622">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="4aca4-623">Если перо находится над дочерним элементом или над элементами, которые являются частью глубокой композиции элемента, это свойство будет иметь `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-623">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="4aca4-624">Если вы знаете, как элемент управления составных (например, это свойство используется в пользовательский шаблон элемента управления для элемента управления, который определяется), это свойство может возвращать непредвиденные результаты.</span><span class="sxs-lookup"><span data-stu-id="4aca4-624">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="4aca4-625">Для большинства сценариев, где вы не создаете элементы управления, используйте <xref:System.Windows.ContentElement.IsStylusOver%2A> вместо этого.</span><span class="sxs-lookup"><span data-stu-id="4aca4-625">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="4aca4-626">Если этот элемент имеет захват пера, и это свойство имеет `true` во время захвата, это свойство остается `true` пока не будет освобождено и перо не выйдет за границы элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-626">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="4aca4-627">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-627">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-628">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-628">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-629">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-629">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-630">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-630">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="4aca4-631">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-631">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-632">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-632">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="F#" Value="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " Usage="member this.IsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-633">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-633">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-634">Этот член является [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событие, не перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-634">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusDirectlyOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-635">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-635">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsStylusOver : bool" Usage="System.Windows.ContentElement.IsStylusOver" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-636">Возвращает значение, определяющее, находится ли перо на элементе (включая видимые дочерние элементы).</span><span class="sxs-lookup"><span data-stu-id="4aca4-636">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span></span></summary>
        <value><span data-ttu-id="4aca4-637"><see langword="true" />, если перо находится на элементе, или его дочерних элементах; иначе, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-637"><see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="4aca4-638">Значение по умолчанию — <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-638">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-639">Если этот элемент имеет захват пера, это свойство остается `true` пока не будет освобождено и указатель мыши выходит за его границы.</span><span class="sxs-lookup"><span data-stu-id="4aca4-639">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="4aca4-640">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-640">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-641">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-641">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="4aca4-642">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="4aca4-642">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-643">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-643">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="4aca4-644">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="4aca4-644">Metadata properties set to `true`</span></span>|<span data-ttu-id="4aca4-645">None</span><span class="sxs-lookup"><span data-stu-id="4aca4-645">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable IsStylusOverProperty : System.Windows.DependencyProperty" Usage="System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-646">Определяет свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-646">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.KeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-647">Возникает при нажатии клавиши, если фокус установлен на данном элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-647">Occurs when a key is pressed while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-648">Обработка клавиш взаимодействует с другими функциями платформы, такие как выполнение команд и текст композиции.</span><span class="sxs-lookup"><span data-stu-id="4aca4-648">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="4aca4-649"><xref:System.Windows.ContentElement.KeyDown> Событие является событием ввода текста более низкого уровня, могут работать некорректно, в конкретных элементах управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-649">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="4aca4-650">Это обусловлено тем, некоторые элементы управления имеют составных элементов управления или обработку классов более высокого уровня версии текста, обработку входных данных и связанные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-650">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="4aca4-651">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.KeyDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-651">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-652">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.KeyDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-652">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-653">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-653">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-654">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-654">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="4aca4-655">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-655">Routing strategy</span></span>|<span data-ttu-id="4aca4-656">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-656">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-657">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-657">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="4aca4-658">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewKeyDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-658">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-659">Переопределить <xref:System.Windows.ContentElement.OnKeyDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-659">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-660">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.KeyDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-660">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-661">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-661">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-662">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-662">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-663">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-663">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-664">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-664">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-665">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-665">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.KeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-666">Происходит при отпускании клавиши, если фокус находится на этом элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-666">Occurs when a key is released while focus is on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-667">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.KeyUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-667">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-668">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.KeyUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-668">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-669">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-669">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-670">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-670">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="4aca4-671">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-671">Routing strategy</span></span>|<span data-ttu-id="4aca4-672">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-672">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-673">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-673">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="4aca4-674">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewKeyUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-674">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-675">Переопределить <xref:System.Windows.ContentElement.OnKeyUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-675">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable KeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.KeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-676">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.KeyUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-676">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-677">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-677">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-678">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-678">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-679">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-679">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-680">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-680">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-681">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-681">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.RoutedEventHandler " Usage="member this.LostFocus : System.Windows.RoutedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-682">Происходит при потере данным элементом логического фокуса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-682">Occurs when this element loses logical focus.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-683">Логический фокус отличается от фокуса ввода, если фокус был намеренно вытеснен посредством вызова метода, но на другом уровне существует предыдущий фокус ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-683">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="4aca4-684">В этом сценарии, остается фокус клавиатуры, где и элемент где <xref:System.Windows.ContentElement.Focus%2A> вызывается метод по-прежнему получает логический фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-684">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="4aca4-685">Более точная Интерпретация значений свойств этого события является он вызывается, когда значение <xref:System.Windows.ContentElement.IsFocused%2A> изменяет свойства элемента в маршруте с `true` для `false`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-685">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="4aca4-686">Вследствие этого события восходящей маршрутизации, элемент, который теряет фокус может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-686">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-687">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, полученная фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-687">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-688">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-688">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-689">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-689">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="4aca4-690">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-690">Routing strategy</span></span>|<span data-ttu-id="4aca4-691">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-691">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-692">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-692">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="4aca4-693">Нет соответствующего события нисходящей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-693">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-694">Переопределить <xref:System.Windows.ContentElement.OnLostFocus%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-694">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-695">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-695">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-696">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-696">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-697">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-697">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-698">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-698">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-699">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-699">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-700">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-700">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.LostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-701">Происходит при потере данным элементом фокуса ввода с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-701">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-702">Вследствие этого события восходящей маршрутизации, элемент, который потерял фокус может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-702">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-703">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, потерявшее фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-703">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="4aca4-704">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.LostKeyboardFocus> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-704">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-705">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.LostKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-705">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-706">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-706">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-707">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-707">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="4aca4-708">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-708">Routing strategy</span></span>|<span data-ttu-id="4aca4-709">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-709">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-710">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-710">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="4aca4-711">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-711">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="4aca4-712">Переопределить <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-712">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-713">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-713">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-714">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-714">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-715">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-715">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-716">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-716">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-717">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-717">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-718">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-718">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberSignature Language="F#" Value="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " Usage="member this.LostMouseCapture : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-719">Происходит при потере элементом захвата мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-719">Occurs when this element loses mouse capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-720">При захвате мыши, он получает ввод от мыши, даже если указатель находится вне границ.</span><span class="sxs-lookup"><span data-stu-id="4aca4-720">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="4aca4-721">Указатель мыши обычно захватывается только во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-721">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="4aca4-722">Вследствие этого события восходящей маршрутизации, элемент, который теряет захват может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-722">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-723">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, который потерял захват.</span><span class="sxs-lookup"><span data-stu-id="4aca4-723">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="4aca4-724">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.LostMouseCapture> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-724">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-725">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.LostMouseCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-725">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-726">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-726">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-727">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-727">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="4aca4-728">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-728">Routing strategy</span></span>|<span data-ttu-id="4aca4-729">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-729">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-730">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-730">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="4aca4-731">Имеется соответствующее событие не определено туннелирования.</span><span class="sxs-lookup"><span data-stu-id="4aca4-731">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-732">Переопределить <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-732">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostMouseCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-733">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostMouseCapture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-733">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-734">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-734">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-735">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-735">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-736">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-736">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-737">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-737">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-738">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-738">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberSignature Language="F#" Value="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " Usage="member this.LostStylusCapture : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-739">Происходит при потере элементом захвата пера.</span><span class="sxs-lookup"><span data-stu-id="4aca4-739">Occurs when this element loses stylus capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-740">При захвате пера, он получает ввод от пера, даже если указатель находится вне границ.</span><span class="sxs-lookup"><span data-stu-id="4aca4-740">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="4aca4-741">Перо обычно захватывается только во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-741">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="4aca4-742">Вследствие этого события восходящей маршрутизации, элемент, который теряет фокус может быть дочерним элементом вместо элемента присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-742">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-743">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, потерявшее фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-743">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="4aca4-744">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.LostStylusCapture> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-744">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-745">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.LostStylusCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-745">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-746">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-746">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-747">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-747">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="4aca4-748">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-748">Routing strategy</span></span>|<span data-ttu-id="4aca4-749">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-749">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-750">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-750">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-751">Имеется соответствующее событие не определено туннелирования.</span><span class="sxs-lookup"><span data-stu-id="4aca4-751">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-752">Переопределить <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-752">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostStylusCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-753">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostStylusCapture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-753">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-754">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-754">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-755">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-755">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-756">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-756">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-757">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-757">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-758">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-758">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberSignature Language="F#" Value="member this.LostTouchCapture : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.LostTouchCapture : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-759">Происходит, когда элемент теряет касание.</span><span class="sxs-lookup"><span data-stu-id="4aca4-759">Occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-760">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-760">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-761">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-761">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="4aca4-762">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-762">Routing strategy</span></span>|<span data-ttu-id="4aca4-763">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-763">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-764">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-764">Delegate</span></span>|<span data-ttu-id="4aca4-765"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-765"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-766">Переопределить <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-766">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable LostTouchCaptureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-767">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostTouchCapture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-767">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-768">Происходит при нажатии любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-768">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-769">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.MouseDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-769">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-770">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-770">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-771"><xref:System.Windows.ContentElement.MouseDown> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.MouseLeftButtonDown> или <xref:System.Windows.ContentElement.MouseRightButtonDown>, соответствующие press одного из двух кнопок стандартных действий мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-771">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="4aca4-772"><xref:System.Windows.ContentElement.MouseLeftButtonDown> и <xref:System.Windows.ContentElement.MouseRightButtonDown> также перенаправленных событий, но они являются прямые перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий достигает этого элемента в маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-772"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="4aca4-773">См. в разделе "Примечания" для <xref:System.Windows.ContentElement.MouseLeftButtonDown> или <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-773">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aca4-774">Несколько <xref:System.Windows.ContentElement> производные классы, которые имеют поведение схожих с элементами управления, например, <xref:System.Windows.Documents.Hyperlink>, может быть реализована собственная обработка события кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-774">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="4aca4-775">Событие нажатия левой кнопки является событие, скорее всего, чтобы класс, обработка в элементе управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-775">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="4aca4-776">Обработку часто класса помечает базовый <xref:System.Windows.Input.Mouse> класс событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-776">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="4aca4-777">После пометки события как обработанного другие обработчики экземпляров, подключенных к этому элементу, не инициируются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-777">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="4aca4-778">Любые другие обработчики класса или экземпляра, присоединенные к элементам в восходящем направлении к корню дерева пользовательского интерфейса, также обычно не инициируются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-778">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="4aca4-779">Можно устранить проблему, описанную в Важном и по-прежнему получать <xref:System.Windows.ContentElement.MouseDown> событий для кнопки мыши в производном классе с обработкой класса с помощью любого из следующих решений:</span><span class="sxs-lookup"><span data-stu-id="4aca4-779">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="4aca4-780">Присоединять обработчики для <xref:System.Windows.ContentElement.PreviewMouseDown> события, который не помечен как обработанное в элементах управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-780">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="4aca4-781">Обратите внимание на то, что так как это события предварительного просмотра, маршрут начинается от корня и туннелируется вниз к элемента управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-781">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="4aca4-782">Процедурному зарегистрировать обработчик для элемента управления путем вызова <xref:System.Windows.ContentElement.AddHandler%2A> и выбрать вариант подписи, который позволяет обработчику прослушивать события, даже если уже отмечены как обработанное в данных перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-782">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-783">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-783">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-784">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-784">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="4aca4-785">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-785">Routing strategy</span></span>|<span data-ttu-id="4aca4-786">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-786">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-787">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-787">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-788">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-788">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-789">Переопределить <xref:System.Windows.ContentElement.OnMouseDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-789">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-790">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-790">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-791">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-791">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-792">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-792">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-793">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-793">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-794">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-794">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-795">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-795">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Input.MouseEventHandler " Usage="member this.MouseEnter : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-796">Происходит, когда указатель мыши попадает внутрь границ данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-796">Occurs when the mouse pointer enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-797"><xref:System.Windows.ContentElement.MouseEnter> — [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-797"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="4aca4-798">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="4aca4-798">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="4aca4-799">Тем не менее они включают другие аспекты поведения перенаправленного события, такие как триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="4aca4-799">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="4aca4-800">Несмотря на то что <xref:System.Windows.ContentElement.MouseEnter> отслеживает, когда указатель мыши попадает внутрь границ элемента, это событие дополнительные буквально о том, что <xref:System.Windows.ContentElement.IsMouseOver%2A> значение свойства было изменено с `false` для `true` данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-800">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="4aca4-801">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.MouseEnter> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-801">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-802">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseEnter> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-802">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-803">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-803">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-804">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-804">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="4aca4-805">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-805">Routing strategy</span></span>|<span data-ttu-id="4aca4-806">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-806">Direct</span></span>|  
|<span data-ttu-id="4aca4-807">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-807">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="4aca4-808">Переопределить <xref:System.Windows.ContentElement.OnMouseEnter%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-808">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-809">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseEnter" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-809">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-810">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-810">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-811">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-811">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-812">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-812">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-813">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-813">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-814">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-814">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Input.MouseEventHandler " Usage="member this.MouseLeave : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-815">Происходит, когда указатель мыши покидает границы данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-815">Occurs when the mouse pointer leaves the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-816"><xref:System.Windows.ContentElement.MouseLeave> — [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-816"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="4aca4-817">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="4aca4-817">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="4aca4-818">Тем не менее они включают другие аспекты поведения перенаправленного события, такие как триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="4aca4-818">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="4aca4-819">Несмотря на то что <xref:System.Windows.ContentElement.MouseLeave> отслеживает, когда мышь покидает элемент, это событие, сведения о том, что буквально <xref:System.Windows.ContentElement.IsMouseOver%2A> значение свойства было изменено с `true` для `false` данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-819">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="4aca4-820">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.MouseLeave> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-820">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-821">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseLeave> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-821">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-822">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-822">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-823">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-823">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="4aca4-824">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-824">Routing strategy</span></span>|<span data-ttu-id="4aca4-825">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-825">Direct</span></span>|  
|<span data-ttu-id="4aca4-826">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-826">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="4aca4-827">Переопределить <xref:System.Windows.ContentElement.OnMouseLeave%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-827">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-828">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseLeave" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-828">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-829">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-829">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-830">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-830">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-831">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-831">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-832">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-832">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-833">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-833">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-834">Происходит при нажатии левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-834">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-835">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-835">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-836">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-836">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-837">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-837">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-838">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-838">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-839">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-839">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-840">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-840">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-841">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-841">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aca4-842">Несколько <xref:System.Windows.ContentElement> производные классы, которые имеют поведение схожих с элементами управления, например, <xref:System.Windows.Documents.Hyperlink>, может быть реализована собственная обработка события кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-842">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="4aca4-843">Событие нажатия левой кнопки является событие, скорее всего, чтобы класс, обработка в элементе управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-843">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="4aca4-844">Обработку часто класса помечает базовый <xref:System.Windows.Input.Mouse> класс событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-844">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="4aca4-845">После пометки события как обработанного другие обработчики экземпляров, подключенных к этому элементу, не инициируются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-845">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="4aca4-846">Любые другие обработчики класса или экземпляра, присоединенные к элементам в восходящем направлении к корню дерева пользовательского интерфейса, также обычно не инициируются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-846">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="4aca4-847">Можно устранить проблему, описанную в Важном и по-прежнему получать <xref:System.Windows.ContentElement.MouseLeftButtonDown> событий для кнопки мыши в производном классе с обработкой класса с помощью любого из следующих решений:</span><span class="sxs-lookup"><span data-stu-id="4aca4-847">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="4aca4-848">Присоединять обработчики для <xref:System.Windows.ContentElement.PreviewMouseDown> события, который не помечен как обработанное в элементах управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-848">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="4aca4-849">Обратите внимание на то, что так как это события предварительного просмотра, маршрут начинается от корня и туннелируется вниз к элемента управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-849">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="4aca4-850">Процедурному зарегистрировать обработчик для элемента управления путем вызова <xref:System.Windows.ContentElement.AddHandler%2A> и выбрать вариант подписи, который позволяет обработчику прослушивать события, даже если уже отмечены как обработанное в данных перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-850">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-851">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-851">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-852">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-852">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="4aca4-853">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-853">Routing strategy</span></span>|<span data-ttu-id="4aca4-854">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-854">Direct</span></span>|  
|<span data-ttu-id="4aca4-855">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-855">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-856">Переопределить <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-856">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-857">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-857">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-858">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-858">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-859">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-859">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-860">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-860">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-861">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-861">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-862">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-862">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-863">Происходит при отпускании левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-863">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-864">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-864">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-865">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-865">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-866">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-866">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-867">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-867">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-868">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-868">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-869">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-869">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-870">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-870">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-871">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-871">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-872">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-872">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="4aca4-873">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-873">Routing strategy</span></span>|<span data-ttu-id="4aca4-874">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-874">Direct</span></span>|  
|<span data-ttu-id="4aca4-875">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-875">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-876">Переопределить <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-876">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-877">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-877">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-878">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-878">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-879">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-879">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-880">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-880">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-881">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-881">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-882">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-882">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.MouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-883">Происходит при перемещении указателя мыши над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-883">Occurs when the mouse pointer moves while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-884">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.MouseMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-884">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-885">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-885">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-886">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-886">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-887">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-887">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="4aca4-888">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-888">Routing strategy</span></span>|<span data-ttu-id="4aca4-889">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-889">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-890">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-890">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="4aca4-891">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-891">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-892">Переопределить <xref:System.Windows.ContentElement.OnMouseMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-892">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-893">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-893">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-894">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-894">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-895">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-895">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-896">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-896">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-897">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-897">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-898">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-898">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-899">Происходит при нажатии правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-899">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-900">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-900">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-901">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-901">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-902">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-902">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-903">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-903">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-904">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-904">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-905">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-905">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-906">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-906">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-907">Часто сценарии приложений имеют обработчики для событий правой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-907">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="4aca4-908">Например правой кнопкой мыши вниз возможно отображение контекстного меню.</span><span class="sxs-lookup"><span data-stu-id="4aca4-908">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="4aca4-909">См. в разделе [Общие сведения о ContextMenu](~/docs/framework/wpf/controls/contextmenu-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-909">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-910">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-910">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-911">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-911">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="4aca4-912">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-912">Routing strategy</span></span>|<span data-ttu-id="4aca4-913">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-913">Direct</span></span>|  
|<span data-ttu-id="4aca4-914">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-914">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-915">Переопределить <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-915">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-916">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-916">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-917">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-917">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-918">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-918">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-919">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-919">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-920">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-920">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-921">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-921">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-922">Происходит при отпускании правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-922">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-923">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-923">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-924">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-924">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-925">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-925">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-926">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-926">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-927">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-927">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-928">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-928">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-929">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-929">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-930">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-930">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-931">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-931">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="4aca4-932">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-932">Routing strategy</span></span>|<span data-ttu-id="4aca4-933">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-933">Direct</span></span>|  
|<span data-ttu-id="4aca4-934">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-934">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-935">Переопределить <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-935">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-936">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-936">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-937">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-937">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-938">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-938">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-939">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-939">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-940">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-940">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-941">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-941">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.MouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-942">Происходит при отпускании любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-942">Occurs when any mouse button is released over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-943">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.MouseUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-943">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-944">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-944">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-945"><xref:System.Windows.ContentElement.MouseUp> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.MouseLeftButtonUp> или <xref:System.Windows.ContentElement.MouseRightButtonUp>, которые соответствуют версии одного из двух кнопок стандартных действий мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-945">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="4aca4-946"><xref:System.Windows.ContentElement.MouseLeftButtonUp> и <xref:System.Windows.ContentElement.MouseRightButtonUp> также перенаправленных событий, но они являются прямые перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий достигает этого элемента в маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-946"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="4aca4-947">См. в разделе "Примечания" для <xref:System.Windows.ContentElement.MouseLeftButtonUp> или <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-947">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-948">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-948">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-949">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-949">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="4aca4-950">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-950">Routing strategy</span></span>|<span data-ttu-id="4aca4-951">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-951">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-952">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-952">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-953">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-953">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-954">Переопределить <xref:System.Windows.ContentElement.OnMouseUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-954">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-955">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-955">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-956">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-956">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-957">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-957">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-958">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-958">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-959">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-959">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-960">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-960">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberSignature Language="F#" Value="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.MouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-961">Происходит при вращении колесика мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-961">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-962">Фокус или захват мыши имеют приоритет над которого указатель мыши; Таким образом при получении <xref:System.Windows.ContentElement.MouseWheel> событий из элемента или получившего указатель мыши может на другом элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-962">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="4aca4-963">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.MouseWheel> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-963">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-964">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseWheel> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-964">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-965">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-965">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-966">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-966">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="4aca4-967">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-967">Routing strategy</span></span>|<span data-ttu-id="4aca4-968">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-968">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-969">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-969">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="4aca4-970">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-970">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="4aca4-971">Переопределить <xref:System.Windows.ContentElement.OnMouseWheel%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-971">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable MouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.MouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-972">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseWheel" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-972">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-973">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-973">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-974">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-974">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-975">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-975">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-976">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-976">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-977">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-977">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberSignature Language="F#" Value="abstract member MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool&#xA;override this.MoveFocus : System.Windows.Input.TraversalRequest -&gt; bool" Usage="contentElement.MoveFocus request" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request"><span data-ttu-id="4aca4-978">Запрос перемещения, содержащий свойство, которое определяет способ перемещения в соответствующем порядке по вкладкам, или направление для визуального перемещения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-978">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span></span></param>
        <summary><span data-ttu-id="4aca4-979">Предпринимает попытки переместить фокус с данного элемента на иной.</span><span class="sxs-lookup"><span data-stu-id="4aca4-979">Attempts to move focus from this element to another element.</span></span> <span data-ttu-id="4aca4-980">Направления для перемещения фокуса задается указанием направления, которое обрабатывается внутри видимого родительского элемента данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-980">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-981"><see langword="true" />, если запрос на перемещение выполнен; иначе, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-981"><see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-982">Убедитесь, что проверяйте возвращаемое значение этого метода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-982">Make sure you check the return value of this method.</span></span> <span data-ttu-id="4aca4-983">Возвращаемое значение, равное `false` может быть возвращено, если затребована табуляции, который определяется компоновка элемента управления и обхода запрос не запрашивает программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-983">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberSignature Language="F#" Value="abstract member OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer&#xA;override this.OnCreateAutomationPeer : unit -&gt; System.Windows.Automation.Peers.AutomationPeer" Usage="contentElement.OnCreateAutomationPeer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-984">Возвращает определяющиеся классом <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> реализации для [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-984">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span></span></summary>
        <returns><span data-ttu-id="4aca4-985">Реализация <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />, зависящая от конкретного типа.</span><span class="sxs-lookup"><span data-stu-id="4aca4-985">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span></span></returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-986">Этот метод реализуется обычно для вызова конкретного конструктора <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> реализации и вернуть его в качестве возвращаемого значения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-986">The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span></span>  
  
<span data-ttu-id="4aca4-987">Все <see cref="T:System.Windows.ContentElement" /> производные классы должны реализовать этот метод, чтобы предоставить свои собственные конкретных <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> реализации [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] инфраструктуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-987">All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span></span> <span data-ttu-id="4aca4-988">Дополнительные сведения о реализации этого шаблона, см. в разделе <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-988">For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-989">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-989">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-990">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragEnter" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-990">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-991">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-991">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-992">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-992">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-993">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-993">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-994">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-994">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-995">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-995">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-996">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-996">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-997">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-997">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-998">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-998">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-999">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-999">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1000">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1000">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1001">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1001">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1002">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragLeave" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1002">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1003">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1003">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1004">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1004">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1005">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1005">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1006">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1006">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1007">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1007">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1008">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1008">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1009">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1009">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1010">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1010">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1011">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1011">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1012">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1012">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1013">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1013">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1014">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragOver" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1014">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1015">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1015">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1016">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1016">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1017">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1017">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1018">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1018">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1019">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1019">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1020">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1020">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1021">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1021">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1022">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1022">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1023">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1023">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1024">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1024">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1025">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1025">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1026">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragEnter" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1026">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1027">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1027">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1028">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1028">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1029">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1029">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1030">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1030">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1031">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1031">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1032">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1032">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1033">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1033">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1034">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1034">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1035">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1035">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1036">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1036">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1037">Объект класса <see cref="T:System.Windows.GiveFeedbackEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1037">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1038">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.GiveFeedback" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1038">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1039">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1039">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1040">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1040">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1041">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1041">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1042">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1042">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1043">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1043">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1044">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1044">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1045">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1045">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1046">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1046">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1047">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1047">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1048">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1048">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnGotFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnGotFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1049">Объект <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1049">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="4aca4-1050">Данные о событии должны содержать идентификатор для события <see cref="E:System.Windows.ContentElement.GotFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1050">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="4aca4-1051">Вызывает перенаправленное событие <see cref="E:System.Windows.ContentElement.GotFocus" /> с помощью предоставленных данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1051">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1052">Этот метод, хотя виртуальным, имеет реализацию по умолчанию, вызывающий событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1052">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="4aca4-1053">Это на \* реализация метода предназначен для вызова события, и эта же реализация вызывается внутренне для вызова события при <xref:System.Windows.ContentElement.IsFocused%2A> изменения значений свойств.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1053">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="4aca4-1054"><xref:System.Windows.ContentElement.OnGotFocus%2A> Реализация отличается от некоторых других [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] на \* реализаций, которые только предоставляют удобный способ добавить обработчик класса для этого события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1054">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-1055">Если у вас нет необходимости преднамеренным и необычные не вызывают события фокуса, убедитесь, что ваша реализация вызывает базовую реализацию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1055">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="4aca4-1056">В противном случае <see cref="E:System.Windows.ContentElement.GotFocus" /> событие не вызывается во время действия пользователя, которые обычно устанавливают фокус в данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1056">Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="4aca4-1057">Если элемент должен иметь возможность получать фокус не требуется, вы может помешать элементу, способному получать фокус, задав <see cref="P:System.Windows.ContentElement.Focusable" /> для <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1057">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span> <span data-ttu-id="4aca4-1058">Обратите внимание, что по умолчанию <see cref="P:System.Windows.ContentElement.Focusable" /> не может получать фокус, поэтому установка <see cref="P:System.Windows.ContentElement.Focusable" /> намеренно может не потребоваться.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1058">Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</span></span></para></block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1059">Объект класса <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1059">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1060">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1060">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1061">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1061">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1062">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1062">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1063">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1063">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1064">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1064">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1065">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1065">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1066">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1066">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1067">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1067">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1068">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1068">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1069">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1069">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1070">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1070">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnGotMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnGotMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1071">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1071">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1072">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1072">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1073">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1073">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1074">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1074">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1075">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1075">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1076">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1076">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1077">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1077">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1078">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1078">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1079">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1079">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1080">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1080">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1081">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1081">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1082">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1082">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnGotStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnGotStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1083">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1083">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1084">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1084">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1085">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1085">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1086">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1086">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1087">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1087">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1088">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1088">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1089">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1089">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1090">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1090">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1091">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1091">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1092">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1092">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1093">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1093">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1094">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1094">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnGotTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnGotTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1095">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1095">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1096">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.GotTouchCapture" />, которое происходит при захвате сенсорного ввода данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1096">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1097"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1097">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1098">Переопределить <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> в производном классе для обработки <xref:System.Windows.ContentElement.GotTouchCapture> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1098">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="4aca4-1099">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1099">Be sure to call the base class' <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1100">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1100">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1101">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1101">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1102">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1102">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1103">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> изменения свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1103">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="4aca4-1104">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1104">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1105">Затем <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1105">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1106">Обратите внимание, что <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1106">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="4aca4-1107">Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1107">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1108">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1108">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1109">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1109">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1110">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1110">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsKeyboardFocusWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsKeyboardFocusWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1111">Объект <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1111">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1112">Вызывается непосредственно перед вызовом события <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1112">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span></span> <span data-ttu-id="4aca4-1113">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1113">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1114">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1114">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1115">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1115">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1116">Затем <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1116">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1117">Обратите внимание, что <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1117">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="4aca4-1118">Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1118">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1119">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1119">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1120">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1120">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1121">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1121">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1122">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1122">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1123">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1123">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1124">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1124">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1125">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsMouseCaptured%2A> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1125">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1126">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1126">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1127">Затем <xref:System.Windows.ContentElement.IsMouseCapturedChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1127">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1128">Обратите внимание, что <xref:System.Windows.ContentElement.IsMouseCapturedChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1128">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="4aca4-1129">Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1129">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1130">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1130">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1131">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1131">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1132">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1132">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1133">Объект <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1133">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1134">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1134">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1135">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1135">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-1136">Этот виртуальный метод вызывается при значение <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1136">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1137">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1137">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1138">Затем <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1138">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1139">Обратите внимание на то, что событие не является маршрутизируемым; Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1139">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span></span>  
  
<span data-ttu-id="4aca4-1140">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1140">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1141">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1141">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1142">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1142">You may call base either before or after your special handling, depending on your requirements.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsMouseDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsMouseDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1143">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1143">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1144">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1144">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1145">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1145">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1146">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1146">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1147">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1147">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1148">Затем <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1148">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1149">Обратите внимание, что <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1149">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="4aca4-1150">Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1150">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1151">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1151">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1152">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1152">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1153">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1153">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCapturedChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCapturedChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1154">Объект <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1154">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1155">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1155">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1156">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1156">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1157">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsStylusCaptured%2A> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1157">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1158">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1158">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1159">Затем <xref:System.Windows.ContentElement.IsStylusCapturedChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1159">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1160">Обратите внимание на то, что событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1160">Notice that the event is not a routed event.</span></span> <span data-ttu-id="4aca4-1161">Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1161">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1162">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1162">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1163">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1163">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1164">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1164">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusCaptureWithinChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusCaptureWithinChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1165">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1165">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1166">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1166">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1167">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1167">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1168">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1168">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1169">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1169">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1170">Затем <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1170">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1171">Обратите внимание на то, что событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1171">Notice that the event is not a routed event.</span></span> <span data-ttu-id="4aca4-1172">Таким образом его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1172">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1173">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1173">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1174">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1174">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1175">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1175">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="F#" Value="abstract member OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit&#xA;override this.OnIsStylusDirectlyOverChanged : System.Windows.DependencyPropertyChangedEventArgs -&gt; unit" Usage="contentElement.OnIsStylusDirectlyOverChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1176">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1176">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1177">Вызывается, когда необработанное событие <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1177">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span></span> <span data-ttu-id="4aca4-1178">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1178">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1179">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> изменении его значения свойства зависимостей.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1179">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="4aca4-1180">Виртуальный метод вызывается первым и можно управлять данными событий, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1180">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="4aca4-1181">Затем <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> события с этой же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1181">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="4aca4-1182">Обратите внимание на то, что событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1182">Notice that the event is not a routed event.</span></span> <span data-ttu-id="4aca4-1183">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1183">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="4aca4-1184">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1184">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1185">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1185">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1186">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1186">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1187">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1187">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1188">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1188">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1189">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1189">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1190">Нажатия клавиш обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1190">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="4aca4-1191">Другие возможности программирования, которые зависят от нажатия клавиш как, например, ввод и привязка команд, могут обрабатывать нажатие клавиши, прежде чем она предоставляется как общее.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1191">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="4aca4-1192">Если эти входные функции системы пометить событие как обработанное, затем <xref:System.Windows.ContentElement.OnKeyDown%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1192">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1193">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1193">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1194">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1194">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1195">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1195">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1196">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1196">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1197">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1197">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1198">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1198">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1199">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1199">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1200">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1200">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1201">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1201">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1202">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1202">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1203">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1203">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1204">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1204">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1205">Нажатия клавиш обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1205">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="4aca4-1206">Другие возможности программирования, которые зависят от нажатия клавиш как, например, ввод и привязка команд, могут обрабатывать нажатие клавиши, прежде чем она предоставляется как общее.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1206">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="4aca4-1207">Если эти входные функции системы пометить событие как обработанное, затем <xref:System.Windows.ContentElement.OnKeyUp%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1207">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1208">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1208">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1209">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1209">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1210">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1210">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1211">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1211">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1212">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1212">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1213">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1213">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1214">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1214">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1215">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1215">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1216">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1216">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.OnLostFocus : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.OnLostFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1217">Объект <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1217">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span></span> <span data-ttu-id="4aca4-1218">Данные о событии должны содержать идентификатор для события <see cref="E:System.Windows.ContentElement.LostFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1218">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span></span></param>
        <summary><span data-ttu-id="4aca4-1219">Вызывает перенаправленное событие <see cref="E:System.Windows.ContentElement.LostFocus" /> с помощью предоставленных данных о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1219">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1220">Этот метод, хотя виртуальным, имеет реализацию по умолчанию, вызывающий событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1220">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="4aca4-1221">Это на \* реализация метода предназначен для вызова события, и эта же реализация вызывается внутренне для вызова события при <xref:System.Windows.ContentElement.IsFocused%2A> изменения значений свойств.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1221">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="4aca4-1222">Эта реализация отличается от некоторых других [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] на \* реализаций, которые только предоставляют удобный способ добавить обработчик класса для этого события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1222">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="4aca4-1223">Если у вас нет необходимости преднамеренным и необычные не вызывают события фокуса, убедитесь, что ваша реализация вызывает базовую реализацию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1223">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span></span> <span data-ttu-id="4aca4-1224">В противном случае <see cref="E:System.Windows.ContentElement.LostFocus" /> событие не вызывается во время действия пользователя, которые обычно устанавливают фокус в данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1224">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span></span> <span data-ttu-id="4aca4-1225">Если элемент должен иметь возможность получать фокус не требуется, вы может помешать элементу, способному получать фокус, задав <see cref="P:System.Windows.ContentElement.Focusable" /> для <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1225">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1226">Объект <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1226">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1227">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1227">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1228">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1228">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1229">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1229">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1230">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1230">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1231">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1231">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1232">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1232">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1233">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1233">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1234">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1234">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1235">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1235">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1236">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1236">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1237">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1237">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnLostMouseCapture : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnLostMouseCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1238">Объект <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1238">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1239">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1239">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1240">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1240">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1241">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1241">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1242">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1242">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1243">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1243">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1244">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1244">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1245">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1245">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1246">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1246">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1247">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1247">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1248">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1248">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1249">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1249">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnLostStylusCapture : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnLostStylusCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1250">Объект <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1250">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1251">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1251">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1252">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1252">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1253">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1253">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1254">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1254">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1255">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1255">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1256">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1256">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1257">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1257">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1258">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1258">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1259">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1259">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1260">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1260">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1261">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1261">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnLostTouchCapture : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnLostTouchCapture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1262">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1262">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1263">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.LostTouchCapture" />, которое происходит при потере захвата сенсорного ввода данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1263">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1264"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1264">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1265">Переопределить <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> в производном классе для обработки <xref:System.Windows.ContentElement.LostTouchCapture> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1265">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="4aca4-1266">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1266">Be sure to call the base class' <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1267">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1267">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1268">Данные этого события содержат сведения о нажатой кнопке мыши и состоянии обработки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1268">This event data reports details about the mouse button that was pressed and the handled state.</span></span></param>
        <summary><span data-ttu-id="4aca4-1269">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.MouseDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1269">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1270">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1270">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1271">Кнопки мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1271">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="4aca4-1272">Другие возможности программирования, которые зависят от действий кнопки мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1272">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="4aca4-1273">Если эти входные знак функций системы <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnMouseDown%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1273">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1274">При использовании данного обработчика класса, чтобы пометить событие как обработанное, потенциально влияет на следующие события: <xref:System.Windows.ContentElement.MouseLeftButtonDown> и <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1274">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="4aca4-1275">Одно из этих событий могут возникать на принимающей элемент при <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> получении.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1275">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="4aca4-1276">Если пометить это событие как обработанное в обработке класса, вложенные события по-прежнему возникают; Тем не менее они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1276">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="4aca4-1277">Если событие обрабатывается в обработку класса, обработчиков экземпляров для под, не вызываются, когда вы явно используете <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1277">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="4aca4-1278">Обработчики классов также не вызываются до эти обработчики классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1278">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="4aca4-1279">При обработке <xref:System.Windows.ContentElement.OnMouseDown%2A>, подразумевает обработку вашего класса составляли все кнопки мыши возможные действия.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1279">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="4aca4-1280">Это поведение может быть нежелательным; Таким образом Будьте осторожны при использовании данного виртуального метода для помечать события как обработанные.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1280">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="4aca4-1281">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может быть более подходящим.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1281">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="4aca4-1282">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1282">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1283">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1283">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1284">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1284">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1285">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1285">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1286">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1286">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1287">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1287">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1288">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1288">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1289">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1289">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1290">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1290">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseEnter : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1291">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1291">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1292">Вызывается, когда необработанное присоединенное событие <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1292">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span></span> <span data-ttu-id="4aca4-1293">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1293">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1294">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1294">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1295">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1295">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1296">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1296">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="4aca4-1297">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1297">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1298">В этом случае соответствующее событие является маршрутизируемым событием с прямой стратегией маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1298">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="4aca4-1299">Пометить событие как обработанное по-прежнему полезно для предотвращения обработчиками (те, которые задают `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1299">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseLeave : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1300">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1300">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1301">Вызывается, когда необработанное присоединенное событие <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1301">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span></span> <span data-ttu-id="4aca4-1302">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1302">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1303">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1303">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1304">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1304">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1305">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1305">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="4aca4-1306">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1306">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1307">В этом случае соответствующее событие является маршрутизируемым событием с прямой стратегией маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1307">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="4aca4-1308">Пометить событие как обработанное по-прежнему полезно для предотвращения обработчиками (те, которые задают `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1308">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1309">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1309">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1310">В данных события сообщается о том, что была нажата левая кнопка мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1310">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="4aca4-1311">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> возникает для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1311">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span></span> <span data-ttu-id="4aca4-1312">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1312">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1313"><xref:System.Windows.ContentElement.MouseLeftButtonDown> Событие отображается передаваться восходящую маршрутизацию событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1313">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1314"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> является базовой событие, которое Пузырьковая маршрутизация, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1314"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="4aca4-1315">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.MouseLeftButtonDown> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1315">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1316">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1316">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1317">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1317">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1318">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1318">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1319">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1319">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1320">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1320">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="4aca4-1321">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1321">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="4aca4-1322">Необходимость вызывать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1322">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="4aca4-1323">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши для предка классов, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1323">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="4aca4-1324">Например, можно получить из <xref:System.Windows.Controls.Button> и переопределить <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> в производном классе без вызова базовой реализации; тем не менее, это переопределение отключает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1324">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1325">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1325">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1326">Данные о событии информируют об отжатии левой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1326">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="4aca4-1327">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1327">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1328">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1328">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1329"><xref:System.Windows.ContentElement.MouseLeftButtonUp> Событие отображается передаваться восходящую маршрутизацию событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1329">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1330"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> является базовой событие, которое Пузырьковая маршрутизация, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1330"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="4aca4-1331">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.MouseLeftButtonUp> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1331">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1332">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1332">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1333">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1333">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1334">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1334">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1335">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1335">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1336">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1336">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1337">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1337">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1338">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.MouseMove" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1338">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1339">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1339">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1340">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1340">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1341">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1341">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1342">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1342">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1343">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1343">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1344">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1344">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1345">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1345">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1346">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1346">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1347">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1347">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1348">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1348">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1349">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1349">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1350">Данные о событии информируют о нажатии правой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1350">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="4aca4-1351">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1351">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1352">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1352">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1353"><xref:System.Windows.ContentElement.MouseRightButtonDown> Событие отображается передаваться восходящую маршрутизацию событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1353">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1354"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> является базовой событие, которое Пузырьковая маршрутизация, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1354"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="4aca4-1355">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.MouseRightButtonDown> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1355">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1356">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1356">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1357">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1357">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1358">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1358">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1359">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1359">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1360">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1360">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="4aca4-1361">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1361">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="4aca4-1362">Необходимость вызывать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1362">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="4aca4-1363">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши для предка классов, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1363">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="4aca4-1364">Например, можно получить из <xref:System.Windows.Controls.Control> и переопределить <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> в производном классе без вызова базового, однако это переопределение отключает контекстные меню службы в элементе управления, которые входят в из <xref:System.Windows.Controls.Control> поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1364">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1365">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1365">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1366">Данные о событии информируют об отпускании правой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1366">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="4aca4-1367">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1367">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1368">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1368">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1369"><xref:System.Windows.ContentElement.MouseRightButtonUp> Событие отображается передаваться восходящую маршрутизацию событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1369">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1370"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> является базовой событие, которое Пузырьковая маршрутизация, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1370"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="4aca4-1371">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.MouseRightButtonUp> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1371">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1372">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1372">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1373">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1373">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1374">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1374">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1375">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1375">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1376">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1376">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1377">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1377">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1378">Данные о событии информируют об отжатии кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1378">The event data reports that the mouse button was released.</span></span></param>
        <summary><span data-ttu-id="4aca4-1379">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.Input.Mouse.MouseUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1379">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1380">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1380">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1381">Кнопки мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1381">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="4aca4-1382">Другие возможности программирования, которые зависят от действий кнопки мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1382">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="4aca4-1383">Если эти входные знак функций системы <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnMouseUp%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1383">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1384">При использовании данного обработчика класса, чтобы пометить событие как обработанное, потенциально влияет на следующие события: <xref:System.Windows.ContentElement.MouseLeftButtonUp> и <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1384">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="4aca4-1385">Одно из этих событий может быть вызвано в элементе принимающей при <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> получении.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1385">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="4aca4-1386">Если пометить это событие как обработанное в обработке класса, вложенные события по-прежнему возникают; Тем не менее они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1386">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="4aca4-1387">Если событие обрабатывается в обработку класса, обработчиков экземпляров для под, не вызываются, когда вы явно используете <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1387">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="4aca4-1388">Обработчики классов также не вызываются до эти обработчики классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1388">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="4aca4-1389">При обработке <xref:System.Windows.ContentElement.OnMouseUp%2A>, подразумевает обработку вашего класса составляли все возможные отпускания кнопки мыши действия.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1389">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="4aca4-1390">Это поведение может быть нежелательным; Таким образом Будьте осторожны при использовании данного виртуального метода для помечать события как обработанные.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1390">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="4aca4-1391">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может быть более подходящим.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1391">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="4aca4-1392">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1392">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1393">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1393">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1394">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1394">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1395">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1395">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1396">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1396">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1397">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1397">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1398">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1398">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1399">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1399">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1400">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1400">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1401">Объект класса <see cref="T:System.Windows.Input.MouseWheelEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1401">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1402">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1402">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1403">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1403">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1404">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1404">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1405">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1405">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1406">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1406">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1407">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1407">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1408">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1408">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1409">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1409">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1410">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1410">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1411">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1411">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1412">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1412">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragEnter : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1413">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1413">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1414">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1414">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1415">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1415">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1416">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1416">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1417">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1417">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1418">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1418">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1419">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1419">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1420">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1420">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1421">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1421">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1422">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1422">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1423">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1423">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1424">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1424">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1425">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1425">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragLeave : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1426">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1426">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1427">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1427">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1428">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1428">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1429">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1429">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1430">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1430">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1431">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1431">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1432">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1432">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1433">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1433">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1434">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1434">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1435">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1435">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1436">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1436">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1437">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1437">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1438">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1438">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDragOver : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDragOver e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1439">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1439">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1440">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1440">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1441">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1441">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1442">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1442">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1443">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1443">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1444">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1444">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1445">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1445">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1446">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1446">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1447">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1447">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1448">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1448">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1449">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1449">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1450">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1450">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1451">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1451">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit&#xA;override this.OnPreviewDrop : System.Windows.DragEventArgs -&gt; unit" Usage="contentElement.OnPreviewDrop e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1452">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1452">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1453">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDrop" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1453">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1454">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1454">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1455">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1455">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1456">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1456">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1457">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1457">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1458">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1458">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1459">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1459">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1460">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1460">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1461">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1461">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1462">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1462">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1463">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1463">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1464">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1464">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit&#xA;override this.OnPreviewGiveFeedback : System.Windows.GiveFeedbackEventArgs -&gt; unit" Usage="contentElement.OnPreviewGiveFeedback e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1465">Объект класса <see cref="T:System.Windows.GiveFeedbackEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1465">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1466">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1466">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1467">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1467">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1468">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1468">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1469">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1469">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1470">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1470">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1471">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1471">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1472">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1472">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1473">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1473">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1474">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1474">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1475">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1475">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1476">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1476">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1477">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1477">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewGotKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1478">Объект класса <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1478">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1479">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1479">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1480">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1480">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1481">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1481">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1482">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1482">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1483">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1483">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1484">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1484">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1485">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1485">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1486">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1486">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1487">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1487">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1488">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1488">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1489">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1489">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1490">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1490">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyDown : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1491">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1491">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1492">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1492">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1493">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1493">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1494">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1494">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1495">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1495">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1496">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1496">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1497">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1497">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1498">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1498">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1499">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1499">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1500">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1500">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1501">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1501">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1502">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1502">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1503">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1503">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit&#xA;override this.OnPreviewKeyUp : System.Windows.Input.KeyEventArgs -&gt; unit" Usage="contentElement.OnPreviewKeyUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1504">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1504">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1505">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1505">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1506">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1506">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1507">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1507">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1508">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1508">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1509">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1509">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1510">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1510">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1511">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1511">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1512">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1512">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1513">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1513">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1514">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1514">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1515">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1515">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1516">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1516">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit&#xA;override this.OnPreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventArgs -&gt; unit" Usage="contentElement.OnPreviewLostKeyboardFocus e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1517">Объект класса <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1517">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1518">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1518">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1519">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1519">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1520">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1520">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1521">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1521">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1522">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1522">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1523">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1523">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1524">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1524">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1525">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1525">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1526">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1526">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1527">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1527">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1528">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1528">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1529">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1529">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1530">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1530">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1531">Данные о событии информируют о нажатии одной или нескольких кнопок мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1531">The event data reports that one or more mouse buttons were pressed.</span></span></param>
        <summary><span data-ttu-id="4aca4-1532">Вызывается, когда необработанное присоединенное перенаправленное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1532">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1533">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1533">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1534">Кнопки мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1534">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="4aca4-1535">Другие возможности программирования, которые зависят от действий кнопки мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1535">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="4aca4-1536">Если эти входные знак функций системы <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1536">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1537">При использовании данного обработчика класса, чтобы пометить событие как обработанное, потенциально влияет на следующие события: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1537">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="4aca4-1538">Одно из этих событий могут возникать на принимающей элемент при <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> получении.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1538">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="4aca4-1539">Если пометить это событие как обработанное в обработке класса, вложенные события по-прежнему возникают; Тем не менее они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1539">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="4aca4-1540">Если событие обрабатывается в обработку класса, обработчиков экземпляров для под, не вызываются, когда вы явно используете <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1540">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="4aca4-1541">Обработчики классов также не вызываются до эти обработчики классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1541">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="4aca4-1542">При обработке <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, подразумевает обработку вашего класса составляли все кнопки мыши возможные действия.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1542">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="4aca4-1543">Это поведение может быть нежелательным; Таким образом Будьте осторожны при использовании данного виртуального метода для помечать события как обработанные.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1543">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="4aca4-1544">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может быть более подходящим.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1544">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="4aca4-1545">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1545">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1546">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1546">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1547">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1547">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1548">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1548">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1549">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1549">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1550">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1550">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1551">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1551">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1552">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1552">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1553">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1553">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1554">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1554">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1555">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1555">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1556">В данных события сообщается о том, что была нажата левая кнопка мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1556">The event data reports that the left mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="4aca4-1557">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1557">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1558">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1558">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1559"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> Отображается передаваться в нисходящей маршрутизации событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1559">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1560"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> является базовой событие, которое туннель маршрутизации, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1560"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="4aca4-1561">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1561">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1562">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1562">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1563">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1563">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1564">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1564">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1565">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1565">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1566">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1566">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="4aca4-1567">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1567">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="4aca4-1568">Необходимость вызывать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1568">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="4aca4-1569">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши для предка классов, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1569">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="4aca4-1570">Например, можно получить из <xref:System.Windows.Controls.Button> и переопределить <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> в производном классе без вызова базовой реализации; тем не менее, это переопределение отключает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1570">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseLeftButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1571">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1571">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1572">Данные о событии информируют об отжатии левой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1572">The event data reports that the left mouse button was released.</span></span></param>
        <summary><span data-ttu-id="4aca4-1573">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1573">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1574">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1574">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1575"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> Отображается передаваться в нисходящей маршрутизации событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1575">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1576"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> является базовой событие, которое туннель маршрутизации, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1576"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="4aca4-1577">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1577">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1578">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1578">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1579">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1579">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1580">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1580">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1581">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1581">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1582">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1582">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit&#xA;override this.OnPreviewMouseMove : System.Windows.Input.MouseEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1583">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1583">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1584">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1584">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1585">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1585">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1586">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1586">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1587">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1587">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1588">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1588">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1589">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1589">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1590">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1590">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1591">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1591">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1592">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1592">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1593">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1593">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1594">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1594">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1595">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1595">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1596">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1596">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1597">Данные о событии информируют о нажатии правой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1597">The event data reports that the right mouse button was pressed.</span></span></param>
        <summary><span data-ttu-id="4aca4-1598">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1598">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1599">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1599">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1600"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> Отображается передаваться в нисходящей маршрутизации событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1600">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1601"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> является базовой событие, которое туннель маршрутизации, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1601"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="4aca4-1602">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1602">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1603">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1603">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1604">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1604">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1605">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1605">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1606">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1606">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1607">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1607">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="4aca4-1608">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1608">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="4aca4-1609">Необходимость вызывать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1609">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="4aca4-1610">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши для предка классов, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1610">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="4aca4-1611">Например, можно получить из <xref:System.Windows.Controls.Control> и переопределить <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> в производном классе без вызова базового, однако это переопределение отключает контекстные меню службы в элементе управления, которые входят в из <xref:System.Windows.Controls.Control> поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1611">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseRightButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1612">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1612">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1613">Данные о событии информируют об отпускании правой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1613">The event data reports that the right mouse button was released.</span></span></param>
        <summary><span data-ttu-id="4aca4-1614">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1614">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1615">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1615">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1616"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> Отображается передаваться в нисходящей маршрутизации событий, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1616">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="4aca4-1617"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> является базовой событие, которое туннель маршрутизации, при этом каждая <xref:System.Windows.ContentElement> по событию, маршрут используется идентичные обработки для генерации событие с прямой маршрутизацией <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1617"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="4aca4-1618">Несмотря на то, что можно пометить <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> событие как обработанное в целях данного элемента, состояние обработки не способно принять к другим элементам на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1618">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="4aca4-1619">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляров (те, которые не был указан `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1619">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1620">Реализация по умолчанию для обработки в события мыши Общие <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1620">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="4aca4-1621">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1621">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="4aca4-1622">В статическом конструкторе производного класса, Зарегистрируйте обработчик альтернативный класс для <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1622">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="4aca4-1623">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1623">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit&#xA;override this.OnPreviewMouseUp : System.Windows.Input.MouseButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1624">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1624">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span></span> <span data-ttu-id="4aca4-1625">Данные о событии информируют об отжатии одной или нескольких кнопок мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1625">The event data reports that one or more mouse buttons were released.</span></span></param>
        <summary><span data-ttu-id="4aca4-1626">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1626">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1627">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1627">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1628">Кнопки мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1628">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="4aca4-1629">Другие возможности программирования, которые зависят от действий кнопки мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1629">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="4aca4-1630">Если эти входные знак функций системы <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1630">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="4aca4-1631">При использовании данного обработчика класса, чтобы пометить событие как обработанное, потенциально влияет на следующие события: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1631">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="4aca4-1632">Одно из этих событий может быть вызвано в элементе принимающей при <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> получении.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1632">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="4aca4-1633">Если пометить это событие как обработанное в обработке класса, вложенные события по-прежнему возникают; Тем не менее они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1633">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="4aca4-1634">Если событие обрабатывается в обработку класса, обработчиков экземпляров для под, не вызываются, когда вы явно используете <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1634">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="4aca4-1635">Обработчики классов также не вызываются до эти обработчики классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1635">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="4aca4-1636">При обработке <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, подразумевает обработку вашего класса составляли все возможные отпускания кнопки мыши действия.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1636">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="4aca4-1637">Это поведение может быть нежелательным; Таким образом Будьте осторожны при использовании данного виртуального метода для помечать события как обработанные.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1637">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="4aca4-1638">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может быть более подходящим.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1638">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="4aca4-1639">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1639">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1640">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1640">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1641">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1641">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1642">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1642">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1643">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1643">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1644">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1644">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1645">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1645">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1646">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1646">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1647">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1647">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit&#xA;override this.OnPreviewMouseWheel : System.Windows.Input.MouseWheelEventArgs -&gt; unit" Usage="contentElement.OnPreviewMouseWheel e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1648">Объект класса <see cref="T:System.Windows.Input.MouseWheelEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1648">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1649">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1649">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1650">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1650">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1651">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1651">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1652">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1652">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1653">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1653">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1654">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1654">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1655">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1655">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1656">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1656">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1657">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1657">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1658">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1658">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1659">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1659">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1660">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1660">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnPreviewQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnPreviewQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1661">Объект класса <see cref="T:System.Windows.QueryContinueDragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1661">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1662">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1662">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1663">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1663">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1664">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1664">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1665">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1665">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1666">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1666">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1667">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1667">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1668">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1668">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1669">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1669">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1670">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1670">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1671">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1671">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1672">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1672">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1673">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1673">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1674">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1674">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1675">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1675">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1676">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1676">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1677">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1677">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1678">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1678">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1679">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1679">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1680">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1680">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1681">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1681">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1682">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1682">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1683">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1683">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1684">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1684">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1685">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1685">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1686">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1686">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnPreviewStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1687">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1687">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1688">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1688">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1689">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1689">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1690">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1690">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1691">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1691">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1692">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1692">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1693">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1693">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1694">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1694">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1695">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1695">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1696">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1696">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1697">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1697">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1698">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1698">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1699">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1699">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnPreviewStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1700">Объект класса <see cref="T:System.Windows.Input.StylusDownEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1700">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1701">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1701">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1702">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1702">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1703">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1703">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1704">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1704">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1705">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1705">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1706">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1706">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1707">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1707">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1708">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1708">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1709">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1709">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1710">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1710">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1711">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1711">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1712">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1712">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1713">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1713">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1714">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1714">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1715">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1715">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1716">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1716">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1717">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1717">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1718">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1718">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1719">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1719">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1720">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1720">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1721">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1721">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1722">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1722">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1723">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1723">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1724">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1724">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1725">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1725">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1726">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1726">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1727">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1727">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1728">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1728">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1729">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1729">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1730">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1730">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1731">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1731">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1732">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1732">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1733">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1733">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1734">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1734">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1735">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1735">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1736">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1736">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1737">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1737">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1738">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1738">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1739">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1739">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1740">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1740">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1741">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1741">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1742">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1742">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1743">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1743">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1744">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1744">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1745">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1745">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1746">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1746">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1747">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1747">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1748">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1748">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1749">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1749">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1750">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1750">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1751">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1751">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1752">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1752">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1753">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1753">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1754">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1754">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1755">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1755">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1756">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1756">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1757">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1757">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1758">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1758">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1759">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1759">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1760">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1760">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1761">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1761">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1762">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1762">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1763">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1763">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1764">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1764">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnPreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1765">Объект класса <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1765">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1766">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1766">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1767">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1767">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1768">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1768">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1769">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1769">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1770">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1770">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1771">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1771">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1772">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1772">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1773">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1773">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1774">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1774">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1775">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1775">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1776">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1776">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1777">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1777">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnPreviewStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnPreviewStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1778">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1778">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1779">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1779">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1780">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1780">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1781">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1781">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1782">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1782">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1783">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1783">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1784">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1784">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1785">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1785">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1786">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1786">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1787">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1787">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1788">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1788">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1789">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1789">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1790">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1790">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnPreviewTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnPreviewTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1791">Объект класса <see cref="T:System.Windows.Input.TextCompositionEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1791">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1792">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1792">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1793">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1793">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1794">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1794">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1795">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1795">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1796">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1796">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1797">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1797">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1798">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1798">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1799">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1799">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1800">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1800">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1801">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1801">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1802">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1802">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="4aca4-1803">В случае, если предназначена для события предварительного просмотра является Пометка их обрабатывать, чтобы соответствующие обработчики класса восходящей маршрутизации, не вызываются.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1803">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1804">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1804">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1805">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.PreviewTouchDown" />, которое происходит при сенсорном нажатии данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1805">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1806"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1806">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1807">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> в производном классе для обработки <xref:System.Windows.ContentElement.PreviewTouchDown> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1807">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="4aca4-1808">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1808">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1809">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1809">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1810">Предоставляет обработку класса для маршрутизируемого события <see cref="E:System.Windows.ContentElement.PreviewTouchMove" />, которое происходит при перемещении касания внутри этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1810">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1811"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1811">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1812">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> в производном классе для обработки <xref:System.Windows.ContentElement.PreviewTouchMove> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1812">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="4aca4-1813">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1813">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnPreviewTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnPreviewTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1814">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1814">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1815">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.PreviewTouchUp" />, которое происходит при прекращении сенсорного нажатия внутри элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1815">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1816"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1816">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1817">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> в производном классе для обработки <xref:System.Windows.ContentElement.PreviewTouchUp> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1817">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="4aca4-1818">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1818">Be sure to call the base class' <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit&#xA;override this.OnQueryContinueDrag : System.Windows.QueryContinueDragEventArgs -&gt; unit" Usage="contentElement.OnQueryContinueDrag e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1819">Объект класса <see cref="T:System.Windows.QueryContinueDragEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1819">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1820">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1820">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1821">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1821">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1822">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1822">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1823">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1823">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1824">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1824">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1825">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1825">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1826">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1826">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1827">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1827">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1828">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1828">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1829">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1829">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1830">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1830">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit&#xA;override this.OnQueryCursor : System.Windows.Input.QueryCursorEventArgs -&gt; unit" Usage="contentElement.OnQueryCursor e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1831">Объект класса <see cref="T:System.Windows.Input.QueryCursorEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1831">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1832">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1832">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1833">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1833">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1834">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1834">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1835">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1835">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1836">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1836">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1837">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1837">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1838">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1838">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1839">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1839">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1840">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1840">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1841">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1841">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1842">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1842">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonDown : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1843">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1843">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1844">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1844">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1845">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1845">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1846">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1846">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1847">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1847">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1848">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1848">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1849">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1849">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1850">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1850">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1851">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1851">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1852">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1852">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1853">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1853">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1854">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1854">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit&#xA;override this.OnStylusButtonUp : System.Windows.Input.StylusButtonEventArgs -&gt; unit" Usage="contentElement.OnStylusButtonUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1855">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1855">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1856">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1856">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1857">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1857">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1858">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1858">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1859">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1859">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1860">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1860">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1861">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1861">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1862">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1862">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1863">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1863">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1864">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1864">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1865">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1865">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1866">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1866">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit&#xA;override this.OnStylusDown : System.Windows.Input.StylusDownEventArgs -&gt; unit" Usage="contentElement.OnStylusDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1867">Объект класса <see cref="T:System.Windows.Input.StylusDownEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1867">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1868">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusDown" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1868">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1869">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1869">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1870">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1870">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1871">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1871">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1872">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1872">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1873">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1873">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1874">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1874">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1875">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1875">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1876">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1876">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1877">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1877">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1878">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1878">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusEnter : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1879">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1879">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1880">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> вызывается этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1880">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span></span> <span data-ttu-id="4aca4-1881">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1881">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1882">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1882">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1883">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1883">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1884">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1884">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="4aca4-1885">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1885">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1886">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1886">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1887">Пометить событие как обработанное по-прежнему полезно для предотвращения обработчиками (те, которые задают `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1887">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInAirMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInAirMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1888">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1888">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1889">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1889">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1890">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1890">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1891">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1891">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1892">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1892">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1893">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1893">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1894">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1894">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1895">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1895">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1896">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1896">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1897">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1897">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1898">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1898">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1899">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1899">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusInRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusInRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1900">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1900">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1901">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1901">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1902">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1902">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1903">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1903">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1904">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1904">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1905">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1905">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1906">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1906">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1907">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1907">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1908">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1908">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1909">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1909">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1910">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1910">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1911">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1911">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusLeave : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1912">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1912">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1913">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> вызывается этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1913">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span></span> <span data-ttu-id="4aca4-1914">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1914">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1915">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1915">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1916">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1916">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="4aca4-1917">Вызов базовой реализации можно до или после особой обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1917">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="4aca4-1918">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1918">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1919">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1919">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1920">Пометить событие как обработанное по-прежнему полезно для предотвращения обработчиками (те, которые задают `handledEventsToo`) вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1920">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusMove : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1921">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1921">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1922">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusMove" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1922">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1923">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1923">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1924">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1924">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1925">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1925">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1926">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1926">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1927">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1927">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1928">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1928">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1929">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1929">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1930">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1930">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1931">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1931">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1932">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1932">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusOutOfRange : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusOutOfRange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1933">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1933">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1934">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1934">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1935">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1935">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1936">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1936">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1937">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1937">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1938">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1938">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1939">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1939">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1940">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1940">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1941">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1941">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1942">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1942">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1943">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1943">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1944">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1944">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit&#xA;override this.OnStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventArgs -&gt; unit" Usage="contentElement.OnStylusSystemGesture e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1945">Объект класса <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1945">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1946">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1946">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1947">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1947">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1948">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1948">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1949">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1949">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1950">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1950">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1951">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1951">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1952">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1952">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1953">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1953">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1954">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1954">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1955">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1955">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1956">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1956">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit&#xA;override this.OnStylusUp : System.Windows.Input.StylusEventArgs -&gt; unit" Usage="contentElement.OnStylusUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1957">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1957">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1958">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusUp" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1958">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1959">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1959">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1960">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1960">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1961">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1961">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1962">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1962">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1963">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1963">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1964">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1964">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1965">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1965">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1966">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1966">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1967">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1967">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1968">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1968">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit&#xA;override this.OnTextInput : System.Windows.Input.TextCompositionEventArgs -&gt; unit" Usage="contentElement.OnTextInput e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1969">Объект класса <see cref="T:System.Windows.Input.TextCompositionEventArgs" />, содержащий данные о событии.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1969">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1970">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> встречает на своем маршруте элемент, производный от этого класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1970">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span></span> <span data-ttu-id="4aca4-1971">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1971">Implement this method to add class handling for this event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1972">Этот метод не имеет значение по умолчанию реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1972">This method has no default implementation.</span></span> <span data-ttu-id="4aca4-1973">Так как промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1973">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="4aca4-1974">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблон событий на \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1974">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="4aca4-1975">В этом случае соответствующее событие является перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1975">In this case the matching event is a routed event.</span></span> <span data-ttu-id="4aca4-1976">Шаблон реализации методы On \* отличается для перенаправленных событий, так как перенаправленное событие может генерироваться дочерний элемент, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1976">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="4aca4-1977">Таким образом реализации необходимо проверить свойства источника данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1977">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="4aca4-1978">Не пытайтесь повторно инициировать событие в большинстве случаев.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1978">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="4aca4-1979">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытого класса, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1979">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="4aca4-1980">Один сценарий, где обработка класса — управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1980">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchDown : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchDown e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1981">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1981">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1982">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchDown" />, которое происходит при сенсорном нажатии внутри данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1982">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1983"><xref:System.Windows.ContentElement.OnTouchDown%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1983">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1984">Переопределить <xref:System.Windows.ContentElement.OnTouchDown%2A> в производном классе для обработки <xref:System.Windows.ContentElement.TouchDown> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1984">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="4aca4-1985">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnTouchDown%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1985">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchEnter : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchEnter e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1986">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1986">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1987">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchEnter" />, которое происходит при сенсорном перемещении внутрь данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1987">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1988"><xref:System.Windows.ContentElement.OnTouchEnter%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1988">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1989">Переопределить <xref:System.Windows.ContentElement.OnTouchEnter%2A> в производном классе для обработки <xref:System.Windows.ContentElement.TouchEnter> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1989">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="4aca4-1990">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnTouchEnter%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1990">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchLeave : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchLeave e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1991">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1991">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1992">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchLeave" />, которое происходит при сенсорном перемещении за границы данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1992">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1993"><xref:System.Windows.ContentElement.OnTouchLeave%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1993">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1994">Переопределить <xref:System.Windows.ContentElement.OnTouchLeave%2A> в производном классе для обработки <xref:System.Windows.ContentElement.TouchLeave> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1994">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="4aca4-1995">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnTouchLeave%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1995">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchMove : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchMove e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-1996">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1996">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-1997">Предоставляет обработку класса для маршрутизируемого события <see cref="E:System.Windows.ContentElement.TouchMove" />, которое происходит при перемещении касания внутри этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1997">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-1998"><xref:System.Windows.ContentElement.OnTouchMove%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1998">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-1999">Переопределить <xref:System.Windows.ContentElement.OnTouchMove%2A> в производном классе для обработки <xref:System.Windows.ContentElement.TouchMove> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-1999">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="4aca4-2000">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnTouchMove%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2000">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit&#xA;override this.OnTouchUp : System.Windows.Input.TouchEventArgs -&gt; unit" Usage="contentElement.OnTouchUp e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-2001">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2001">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span></span></param>
        <summary><span data-ttu-id="4aca4-2002">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchUp" />, которое происходит при прекращении сенсорного нажатия внутри элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2002">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2003"><xref:System.Windows.ContentElement.OnTouchUp%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2003">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="4aca4-2004">Переопределить <xref:System.Windows.ContentElement.OnTouchUp%2A> в производном классе для обработки <xref:System.Windows.ContentElement.TouchUp> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2004">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="4aca4-2005">Не забудьте вызвать базовый класс <xref:System.Windows.ContentElement.OnTouchUp%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2005">Be sure to call the base class' <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberSignature Language="F#" Value="abstract member PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject&#xA;override this.PredictFocus : System.Windows.Input.FocusNavigationDirection -&gt; System.Windows.DependencyObject" Usage="contentElement.PredictFocus direction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction"><span data-ttu-id="4aca4-2006">Главное направление запроса на перемещение фокуса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2006">The direction of the requested focus traversal.</span></span></param>
        <summary><span data-ttu-id="4aca4-2007">При переопределении в производном классе возвращает элемент, который должен получить фокус для указанного направления перемещения фокуса без перемещения фокуса на этот элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2007">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-2008">Элемент, который мог получить фокус при фактическом вызове <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2008">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2009">Реализация по умолчанию этого метода в данном классе является неполной и всегда возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2009">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragEnter : System.Windows.DragEventHandler " Usage="member this.PreviewDragEnter : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2010">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2010">Occurs when the input system reports an underlying drag event with this element as the drag target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2011">Это событие создает псевдоним для <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDragEnter> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2011">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2012">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDragEnter> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2012">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2013">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2013">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2014">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2014">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="4aca4-2015">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2015">Routing strategy</span></span>|<span data-ttu-id="4aca4-2016">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2016">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2017">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2017">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-2018">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.DragEnter>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2018">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="4aca4-2019">Переопределить <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2019">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2020">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDragEnter" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2020">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2021">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2021">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2022">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2022">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2023">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2023">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2024">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2024">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2025">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2025">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragLeave : System.Windows.DragEventHandler " Usage="member this.PreviewDragLeave : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2026">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2026">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2027">Это событие создает псевдоним для <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDragLeave> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2027">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2028">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDragLeave> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2028">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2029">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2029">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2030">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2030">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="4aca4-2031">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2031">Routing strategy</span></span>|<span data-ttu-id="4aca4-2032">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2032">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2033">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2033">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-2034">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.DragLeave>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2034">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="4aca4-2035">Переопределить <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2035">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2036">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDragLeave" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2036">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2037">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2037">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2038">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2038">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2039">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2039">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2040">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2040">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2041">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2041">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberSignature Language="F#" Value="member this.PreviewDragOver : System.Windows.DragEventHandler " Usage="member this.PreviewDragOver : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2042">Происходит, когда подсистема ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве потенциальной цели данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2042">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2043">Это событие создает псевдоним для <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDragOver> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2043">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2044">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDragOver> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2044">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2045">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2045">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2046">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2046">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="4aca4-2047">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2047">Routing strategy</span></span>|<span data-ttu-id="4aca4-2048">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2048">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2049">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2049">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-2050">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.DragOver>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2050">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="4aca4-2051">Переопределить <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2051">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDragOverEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2052">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDragOver" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2052">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2053">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2053">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2054">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2054">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2055">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2055">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2056">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2056">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2057">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2057">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberSignature Language="F#" Value="member this.PreviewDrop : System.Windows.DragEventHandler " Usage="member this.PreviewDrop : System.Windows.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2058">Происходит, когда система ввода сообщает о базовом событии удаления с этим элементом в качестве цели удаления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2058">Occurs when the input system reports an underlying drop event with this element as the drop target.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2059">Это событие создает псевдоним для <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDrop> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2059">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2060">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDrop> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2060">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2061">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2061">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2062">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2062">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="4aca4-2063">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2063">Routing strategy</span></span>|<span data-ttu-id="4aca4-2064">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2064">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2065">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2065">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="4aca4-2066">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.Drop>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2066">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="4aca4-2067">Переопределить <xref:System.Windows.ContentElement.OnPreviewDrop%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2067">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewDropEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewDropEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2068">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDrop" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2068">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2069">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2069">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2070">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2070">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2071">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2071">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2072">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2072">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2073">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2073">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " Usage="member this.PreviewGiveFeedback : System.Windows.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2074">Происходит при начале операции перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2074">Occurs when a drag-and-drop operation is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2075"><xref:System.Windows.ContentElement.PreviewGiveFeedback> Событий позволяет источнику события перетаскивания изменять внешний вид указателя мыши, чтобы обеспечить пользователю визуальную обратную связь во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2075">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="4aca4-2076">Это событие создает псевдоним для <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewGiveFeedback> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2076">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2077">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewGiveFeedback> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2077">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2078">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2078">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2079">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2079">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="4aca4-2080">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2080">Routing strategy</span></span>|<span data-ttu-id="4aca4-2081">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2081">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2082">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2082">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="4aca4-2083">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.GiveFeedback>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2083">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="4aca4-2084">Переопределить <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2084">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGiveFeedbackEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2085">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2085">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2086">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2086">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2087">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2087">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2088">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2088">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2089">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2089">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2090">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2090">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewGotKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2091">Происходит при получении данным элементом фокуса ввода с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2091">Occurs when the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2092">Так как это событие нисходящей маршрутизации, элемент, имеющий фокус может быть дочерний элемент, а не элемент присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2092">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-2093">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, имеющий фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2093">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="4aca4-2094">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2094">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2095">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2095">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2096">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2096">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2097">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2097">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="4aca4-2098">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2098">Routing strategy</span></span>|<span data-ttu-id="4aca4-2099">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2099">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2100">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2100">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="4aca4-2101">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2101">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="4aca4-2102">Переопределить <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2102">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewGotKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2103">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2103">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2104">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2104">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2105">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2105">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2106">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2106">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2107">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2107">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2108">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2108">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyDown : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2109">Происходит при нажатии клавиши, если фокус ввода с клавиатуры находится на данном элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2109">Occurs when a key is pressed while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2110">Обработка клавиш взаимодействует с другими функциями платформы, такие как выполнение команд и текст композиции.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2110">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="4aca4-2111"><xref:System.Windows.ContentElement.KeyDown> Событие является событием ввода текста более низкого уровня, могут работать некорректно, в конкретных элементах управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2111">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="4aca4-2112">Это обусловлено тем, некоторые элементы управления имеют составных элементов управления или обработку классов более высокого уровня версии текста, обработку входных данных и связанные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2112">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="4aca4-2113">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewKeyDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2113">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2114">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewKeyDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2114">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2115">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2115">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2116">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2116">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="4aca4-2117">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2117">Routing strategy</span></span>|<span data-ttu-id="4aca4-2118">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2118">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2119">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2119">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="4aca4-2120">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2120">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2121">Переопределить <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2121">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2122">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewKeyDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2122">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2123">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2123">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2124">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2124">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2125">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2125">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2126">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2126">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2127">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2127">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " Usage="member this.PreviewKeyUp : System.Windows.Input.KeyEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2128">Происходит при отпускании клавиши, если фокус ввода с клавиатуры находится на данном элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2128">Occurs when a key is released while the keyboard is focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2129">Обработка клавиш взаимодействует с другими функциями платформы, такие как выполнение команд и текст композиции.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2129">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="4aca4-2130"><xref:System.Windows.ContentElement.KeyUp> Событие является событием ввода текста более низкого уровня, могут работать некорректно, в конкретных элементах управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2130">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="4aca4-2131">Это обусловлено тем, некоторые элементы управления имеют составных элементов управления или обработку классов более высокого уровня версии текста, обработку входных данных и связанные события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2131">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="4aca4-2132">Дополнительные сведения обратитесь к документации для отдельных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2132">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="4aca4-2133">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewKeyUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2133">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2134">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewKeyUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2134">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2135">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2135">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2136">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2136">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="4aca4-2137">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2137">Routing strategy</span></span>|<span data-ttu-id="4aca4-2138">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2138">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2139">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2139">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="4aca4-2140">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.KeyUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2140">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2141">Переопределить <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2141">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewKeyUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2142">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewKeyUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2142">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2143">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2143">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2144">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2144">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2145">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2145">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2146">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2146">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2147">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2147">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberSignature Language="F#" Value="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " Usage="member this.PreviewLostKeyboardFocus : System.Windows.Input.KeyboardFocusChangedEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2148">Происходит при потере данным элементом фокуса ввода с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2148">Occurs when the keyboard is no longer focused on this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2149">Так как это событие нисходящей маршрутизации, элемент, который потерял фокус может быть дочерний элемент, а не элемент присоединенного обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2149">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="4aca4-2150">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, потерявшее фокус.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2150">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="4aca4-2151">Это событие создает псевдоним для <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2151">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2152">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2152">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2153">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2153">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2154">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2154">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="4aca4-2155">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2155">Routing strategy</span></span>|<span data-ttu-id="4aca4-2156">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2156">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2157">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2157">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="4aca4-2158">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2158">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="4aca4-2159">Переопределить <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2159">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewLostKeyboardFocusEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2160">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2160">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2161">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2161">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2162">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2162">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2163">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2163">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2164">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2164">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2165">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2165">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2166">Происходит при нажатии любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2166">Occurs when any mouse button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2167">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2167">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2168">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2168">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2169"><xref:System.Windows.ContentElement.PreviewMouseDown> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, соответствующие press одного из двух кнопок стандартных действий мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2169">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="4aca4-2170"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> также перенаправленных событий, но они являются прямые перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событий достигает этого элемента в маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2170"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="4aca4-2171">См. в разделе "Примечания" для <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2171">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2172">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2172">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2173">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2173">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="4aca4-2174">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2174">Routing strategy</span></span>|<span data-ttu-id="4aca4-2175">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2175">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2176">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2176">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2177">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.MouseDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2177">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2178">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2178">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2179">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2179">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2180">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2180">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2181">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2181">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2182">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2182">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2183">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2183">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2184">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2184">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2185">Происходит при нажатии левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2185">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2186">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется нисходящей маршрутизации через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2186">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-2187">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2187">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-2188">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2188">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-2189">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2189">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-2190">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2190">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-2191">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2191">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-2192">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2192">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2193">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2193">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2194">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2194">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="4aca4-2195">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2195">Routing strategy</span></span>|<span data-ttu-id="4aca4-2196">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2196">Direct</span></span>|  
|<span data-ttu-id="4aca4-2197">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2197">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2198">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2198">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2199">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2199">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2200">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2200">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2201">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2201">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2202">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2202">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2203">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2203">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2204">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2204">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseLeftButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2205">Происходит при отпускании левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2205">Occurs when the left mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2206">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется нисходящей маршрутизации через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2206">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-2207">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2207">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-2208">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2208">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-2209">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2209">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-2210">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2210">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-2211">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2211">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-2212">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2212">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2213">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2213">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2214">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2214">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="4aca4-2215">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2215">Routing strategy</span></span>|<span data-ttu-id="4aca4-2216">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2216">Direct</span></span>|  
|<span data-ttu-id="4aca4-2217">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2217">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2218">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2218">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseLeftButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2219">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2219">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2220">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2220">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2221">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2221">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2222">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2222">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2223">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2223">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2224">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2224">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " Usage="member this.PreviewMouseMove : System.Windows.Input.MouseEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2225">Происходит при перемещении указателя мыши, когда он находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2225">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2226">Это событие происходит, и когда указатель мыши входит в пределы элемента, и когда указатель мыши перемещается, оставаясь в пределах его границ.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2226">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="4aca4-2227">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2227">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2228">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2228">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2229">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2229">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2230">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2230">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="4aca4-2231">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2231">Routing strategy</span></span>|<span data-ttu-id="4aca4-2232">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2232">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2233">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2233">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="4aca4-2234">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.MouseMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2234">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2235">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2235">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2236">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2236">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2237">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2237">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2238">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2238">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2239">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2239">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2240">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2240">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2241">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2241">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonDown : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2242">Происходит при нажатии правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2242">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2243">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется нисходящей маршрутизации через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2243">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-2244">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2244">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-2245">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2245">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-2246">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2246">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-2247">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2247">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-2248">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2248">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-2249">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2249">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2250">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2250">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2251">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2251">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="4aca4-2252">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2252">Routing strategy</span></span>|<span data-ttu-id="4aca4-2253">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2253">Direct</span></span>|  
|<span data-ttu-id="4aca4-2254">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2254">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2255">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2255">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2256">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2256">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2257">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2257">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2258">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2258">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2259">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2259">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2260">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2260">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2261">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2261">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseRightButtonUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2262">Происходит при отпускании правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2262">Occurs when the right mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2263">Несмотря на то что это [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется нисходящей маршрутизации через дерево элементов, фактически является прямой перенаправленное событие, которое возникает и восходящему на дереве элементов друг <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2263">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="4aca4-2264">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событие, которое является присоединенного события, обрабатываемого каждым элементом на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2264">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="4aca4-2265">Аргументы события предоставляют аргументы базового <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2265">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="4aca4-2266">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с параметром для обработки событий, которые уже отмечены как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2266">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="4aca4-2267">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2267">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="4aca4-2268">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (влево и вправо, вверх вниз) из исходных событий мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2268">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="4aca4-2269">Для более сложных сценариев, таких как проверка для состояний нестандартных кнопок, может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2269">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2270">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2270">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2271">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2271">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="4aca4-2272">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2272">Routing strategy</span></span>|<span data-ttu-id="4aca4-2273">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2273">Direct</span></span>|  
|<span data-ttu-id="4aca4-2274">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2274">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2275">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2275">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseRightButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2276">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2276">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2277">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2278">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2279">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2280">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2281">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " Usage="member this.PreviewMouseUp : System.Windows.Input.MouseButtonEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2282">Происходит при отпускании любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2282">Occurs when any mouse button is released while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2283">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2283">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2284">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2284">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2285"><xref:System.Windows.ContentElement.PreviewMouseUp> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, соответствующие press одного из двух кнопок стандартных действий мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2285">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="4aca4-2286"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> также перенаправленных событий, но они являются прямые перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событий достигает этого элемента в маршруте события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2286"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="4aca4-2287">См. в разделе "Примечания" для <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2287">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2288">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2288">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2289">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2289">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="4aca4-2290">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2290">Routing strategy</span></span>|<span data-ttu-id="4aca4-2291">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2291">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2292">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2292">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2293">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.MouseUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2293">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2294">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2294">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2295">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2295">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2296">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2296">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2297">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2297">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2298">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2298">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2299">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2299">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2300">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2300">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberSignature Language="F#" Value="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " Usage="member this.PreviewMouseWheel : System.Windows.Input.MouseWheelEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2301">Происходит при вращении колесика мыши в тот момент, когда указатель мыши находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2301">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2302">Фокус или захват мыши имеют приоритет над которого указатель мыши; Таким образом при получении этого события из элемента или получившего, указатель мыши фактически может находиться на другом элементе.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2302">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="4aca4-2303">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2303">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2304">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2304">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2305">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2305">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2306">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2306">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="4aca4-2307">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2307">Routing strategy</span></span>|<span data-ttu-id="4aca4-2308">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2308">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2309">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2309">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="4aca4-2310">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.MouseWheel>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2310">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="4aca4-2311">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2311">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewMouseWheelEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2312">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2312">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2313">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2313">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2314">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2314">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2315">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2315">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2316">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2316">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2317">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2317">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.PreviewQueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2318">Происходит, когда состояние клавиши или кнопки мыши изменяется в ходе операции перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2318">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2319"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag> Событий позволяет источнику перетаскивания для объявления того, должна ли быть отменена операция перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2319">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="4aca4-2320">Это событие создает псевдоним для <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2320">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2321">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2321">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2322">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2322">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2323">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2323">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="4aca4-2324">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2324">Routing strategy</span></span>|<span data-ttu-id="4aca4-2325">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2325">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2326">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2326">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="4aca4-2327">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.QueryContinueDrag>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2327">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="4aca4-2328">Переопределить <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2328">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewQueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2329">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2329">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2330">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2330">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2331">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2331">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2332">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2332">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2333">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2333">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2334">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2334">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2335">Происходит при нажатии кнопки пера в тот момент, когда указатель находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2335">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2336">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusButtonDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2336">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2337">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusButtonDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2337">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2338">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2338">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2339">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2339">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2340">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2340">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2341">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2341">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="4aca4-2342">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2342">Routing strategy</span></span>|<span data-ttu-id="4aca4-2343">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2343">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2344">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2344">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2345">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2345">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2346">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2346">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2347">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2347">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2348">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2348">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2349">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2349">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2350">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2350">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2351">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2351">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2352">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2352">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.PreviewStylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2353">Происходит при отпускании кнопки пера в тот момент, когда указатель находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2353">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2354">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusButtonUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2354">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2355">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusButtonUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2355">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2356">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2356">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2357">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2357">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2358">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2358">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2359">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2359">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="4aca4-2360">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2360">Routing strategy</span></span>|<span data-ttu-id="4aca4-2361">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2361">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2362">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2362">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2363">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2363">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2364">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2364">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2365">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2365">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2366">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2366">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2367">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2367">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2368">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2368">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2369">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2369">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2370">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2370">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.PreviewStylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2371">Происходит при касании дигитайзера пером в тот момент, когда оно находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2371">Occurs when the stylus touches the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2372">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2372">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2373">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2373">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2374">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2374">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2375">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2375">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2376">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2376">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2377">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2377">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="4aca4-2378">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2378">Routing strategy</span></span>|<span data-ttu-id="4aca4-2379">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2379">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2380">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2380">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="4aca4-2381">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2381">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2382">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2382">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2383">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2383">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2384">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2384">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2385">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2385">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2386">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2386">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2387">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2387">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2388">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2388">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2389">Происходит при движении пера над элементом без касания дигитайзера.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2389">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2390">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusInAirMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2390">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2391">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusInAirMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2391">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2392">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2392">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2393">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2393">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2394">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2394">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2395">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2395">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="4aca4-2396">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2396">Routing strategy</span></span>|<span data-ttu-id="4aca4-2397">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2397">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2398">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2398">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2399">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusInAirMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2399">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2400">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2400">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2401">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2401">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2402">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2402">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2403">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2403">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2404">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2404">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2405">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2405">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2406">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2406">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2407">Происходит при нахождении пера над данным элементом достаточно близко для того, чтобы перо было обнаружено дигитайзером.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2407">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2408">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusInRange> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2408">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2409">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusInRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2409">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2410">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2410">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2411">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2411">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2412">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2412">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2413">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2413">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="4aca4-2414">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2414">Routing strategy</span></span>|<span data-ttu-id="4aca4-2415">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2415">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2416">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2416">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2417">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusInRange>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2417">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="4aca4-2418">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2418">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2419">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2419">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2420">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2420">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2421">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2421">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2422">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2422">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2423">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2423">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2424">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2424">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2425">Происходит при перемещении пера над элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2425">Occurs when the stylus moves while over the element.</span></span> <span data-ttu-id="4aca4-2426">Для вызова этого события перемещаемое перо должно быть обнаружено дигитайзером; в противном случае вызывается <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2426">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2427">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2427">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2428">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2428">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2429">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2429">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2430">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2430">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2431">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2431">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2432">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2432">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="4aca4-2433">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2433">Routing strategy</span></span>|<span data-ttu-id="4aca4-2434">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2434">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2435">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2435">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2436">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2436">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2437">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2437">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2438">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2438">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2439">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2439">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2440">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2440">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2441">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2441">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2442">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2442">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2443">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2443">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2444">Происходит, когда перо находится слишком далеко от дигитайзера, чтобы быть обнаруженным.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2444">Occurs when the stylus is too far from the digitizer to be detected.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2445">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2445">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2446">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2446">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2447">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2447">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2448">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2448">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2449">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2449">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2450">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2450">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="4aca4-2451">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2451">Routing strategy</span></span>|<span data-ttu-id="4aca4-2452">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2452">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2453">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2453">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2454">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusOutOfRange>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2454">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="4aca4-2455">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2455">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2456">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2456">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2457">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2457">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2458">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2458">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2459">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2459">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2460">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2460">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2461">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2461">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.PreviewStylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2462">Происходит при использовании пользователем одного из жестов пером.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2462">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2463">Сведения о жестов пером, см. в разделе <xref:System.Windows.Input.SystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2463">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="4aca4-2464">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2464">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2465">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2465">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2466">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2466">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2467">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2467">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2468">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2468">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2469">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2469">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="4aca4-2470">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2470">Routing strategy</span></span>|<span data-ttu-id="4aca4-2471">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2471">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2472">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2472">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="4aca4-2473">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusSystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2473">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="4aca4-2474">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2474">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2475">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2475">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2476">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2476">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2477">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2477">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2478">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2478">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2479">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2479">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2480">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2480">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.PreviewStylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2481">Происходит, когда пользователь отрывает перо от поверхности дигитайзера в тот момент, когда оно находится над этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2481">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2482">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2482">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2483">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2483">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2484">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2484">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2485">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2485">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2486">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2486">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2487">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2487">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="4aca4-2488">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2488">Routing strategy</span></span>|<span data-ttu-id="4aca4-2489">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2489">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2490">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2490">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2491">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.StylusUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2491">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2492">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2492">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewStylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2493">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2493">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2494">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2494">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2495">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2495">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2496">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2496">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2497">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2497">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2498">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2498">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberSignature Language="F#" Value="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.PreviewTextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2499">Происходит при получении этим элементом текста аппаратно-независимым способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2499">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2500"><xref:System.Windows.ContentElement.PreviewTextInput> Событие позволяет компонента или приложения для ожидания передачи данных для ввода текста в аппаратно независимым способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2500">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="4aca4-2501">Клавиатура является основным средством <xref:System.Windows.ContentElement.PreviewTextInput>; но речи, рукописного ввода и других устройств ввода также может сформировать <xref:System.Windows.ContentElement.PreviewTextInput>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2501">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="4aca4-2502">Из-за сочетания клавиш - клавиатуры по умолчанию или редакторам методов ввода — несколько ключевых событий может вызывать только одно событие ввода текста.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2502">Because of key combinations - either in default keyboards or through input method editors - multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="4aca4-2503">Это событие создает псевдоним для <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewTextInput> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2503">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2504">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewTextInput> событий присоединяются к базовому объекту <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2504">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2505">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2505">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2506">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2506">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="4aca4-2507">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2507">Routing strategy</span></span>|<span data-ttu-id="4aca4-2508">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2508">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2509">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2509">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="4aca4-2510">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.TextInput>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2510">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="4aca4-2511">Переопределить <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2511">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2512">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTextInput" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2512">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2513">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2513">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2514">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2514">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2515">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2515">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2516">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2516">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2517">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2517">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2518">Происходит при касании пальцем экрана, когда палец находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2518">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2519">По умолчанию <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> пока палец касается экрана и перемещает события не происходят.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2519">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="4aca4-2520">Нажав пальцем на экране и удерживает без его перемещения то прессе и удерживайте поведение <xref:System.Windows.Input.Stylus>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2520">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="4aca4-2521">Нажмите и удерживайте клавишу поведение соответствует щелчку правой кнопкой мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2521">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="4aca4-2522">Чтобы вызвать <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> событий по мере палец касается экрана, задать <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> вложенное свойство, чтобы `false` для данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2522">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2523">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2523">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2524">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2524">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="4aca4-2525">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2525">Routing strategy</span></span>|<span data-ttu-id="4aca4-2526">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2526">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2527">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2527">Delegate</span></span>|<span data-ttu-id="4aca4-2528"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2528"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2529">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.TouchDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2529">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2530">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2530">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2531">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTouchDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2531">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2532">Возникает при перемещении пальца по экрану при условии, если палец находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2532">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2533">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2533">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2534">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2534">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="4aca4-2535">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2535">Routing strategy</span></span>|<span data-ttu-id="4aca4-2536">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2536">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2537">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2537">Delegate</span></span>|<span data-ttu-id="4aca4-2538"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2538"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2539">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.TouchMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2539">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2540">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2540">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2541">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTouchMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2541">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberSignature Language="F#" Value="member this.PreviewTouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.PreviewTouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2542">Возникает, когда палец отрывается от экрана при условии, что палец находится над этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2542">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2543">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2543">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2544">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2544">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="4aca4-2545">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2545">Routing strategy</span></span>|<span data-ttu-id="4aca4-2546">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="4aca4-2546">Tunneling</span></span>|  
|<span data-ttu-id="4aca4-2547">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2547">Delegate</span></span>|<span data-ttu-id="4aca4-2548"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2548"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2549">Соответствующее событие восходящей маршрутизации — <xref:System.Windows.ContentElement.TouchUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2549">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2550">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2550">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable PreviewTouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2551">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTouchUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2551">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2552">Происходит, когда состояние клавиши или кнопки мыши изменяется в ходе операции перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2552">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2553"><xref:System.Windows.ContentElement.QueryContinueDrag> Событие позволяет источнику перетаскивания определить, следует ли отменить операцию перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2553">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="4aca4-2554">Это событие создает псевдоним для <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.QueryContinueDrag> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2554">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2555">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.QueryContinueDrag> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2555">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2556">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2556">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2557">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2557">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="4aca4-2558">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2558">Routing strategy</span></span>|<span data-ttu-id="4aca4-2559">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2559">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2560">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2560">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="4aca4-2561">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2561">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="4aca4-2562">Переопределить <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2562">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryContinueDragEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2563">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.QueryContinueDrag" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2563">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2564">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2564">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2565">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2565">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2566">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2566">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2567">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2567">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2568">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2568">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberSignature Language="F#" Value="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " Usage="member this.QueryCursor : System.Windows.Input.QueryCursorEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2569">Происходит при запросе отображения курсора.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2569">Occurs when the cursor is requested to display.</span></span> <span data-ttu-id="4aca4-2570">Это событие возникает для элемента каждый раз, когда указатель мыши перемещается в новое положение, что может послужить причиной изменения его внешнего вида.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2570">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2571">Это событие создает псевдоним для <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.QueryCursor> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2571">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2572">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.QueryCursor> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2572">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2573">Курсор, который ссылается это имя события не обязательно текстовый курсор (которую иногда называют точка вставки).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2573">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="4aca4-2574">Вместо этого курсора в данном контексте — это объект, который объявляет графическое отображение на экране, связанные с несколькими возможными устройствами ввода или концепциями в программировании Windows.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2574">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in Windows programming.</span></span> <span data-ttu-id="4aca4-2575">Этот объект представляется <xref:System.Windows.Input.Cursor> класса WPF.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2575">That object is represented by the <xref:System.Windows.Input.Cursor> class in WPF.</span></span> <span data-ttu-id="4aca4-2576">Система ввода WPF позволяет изменять этот курсор, когда он представляет положение на экране указателя мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2576">The WPF input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="4aca4-2577">Можно использовать предопределенные значения из <xref:System.Windows.Input.Cursors> перечисление, или можно объявить пользовательский курсор в виде файла изображения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2577">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="4aca4-2578">Прослушивание <xref:System.Windows.ContentElement.QueryCursor> событие не является эффективным методика управления курсора.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2578">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="4aca4-2579">Вместо этого каждый элемент должен определить собственное поведение курсора с <xref:System.Windows.FrameworkContentElement.Cursor%2A> и <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2579">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="4aca4-2580">Следует полагаться на <xref:System.Windows.ContentElement.QueryCursor> Если вы не используете базовые элементы уровня платформы WPF, или в непредвиденных случаях, когда определение работы курсоров, на основе каждого элемента не соответствует вашим потребностям.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2580">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="4aca4-2581">Дополнительные сведения о реализации режима работы курсоров в ответ на <xref:System.Windows.ContentElement.QueryCursor>, см. в разделе <xref:System.Windows.Input.QueryCursorEventHandler>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2581">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2582">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2582">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2583">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2583">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="4aca4-2584">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2584">Routing strategy</span></span>|<span data-ttu-id="4aca4-2585">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2585">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2586">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2586">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="4aca4-2587">Имеется соответствующее событие не определено туннелирования.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2587">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="4aca4-2588">Переопределить <xref:System.Windows.ContentElement.OnQueryCursor%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2588">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable QueryCursorEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.QueryCursorEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2589">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.QueryCursor" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2589">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2590">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2590">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2591">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2591">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2592">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2592">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2593">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2593">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2594">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2594">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit&#xA;override this.RaiseEvent : System.Windows.RoutedEventArgs -&gt; unit" Usage="contentElement.RaiseEvent e" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="4aca4-2595">Объект <see cref="T:System.Windows.RoutedEventArgs" />, который содержит данные события, а также определяет инициируемое событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2595">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span></span></param>
        <summary><span data-ttu-id="4aca4-2596">Инициирует определенное перенаправленное событие.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2596">Raises a specific routed event.</span></span> <span data-ttu-id="4aca4-2597">Инициируемое событие <see cref="T:System.Windows.RoutedEvent" /> указывается в предоставленном экземпляре <see cref="T:System.Windows.RoutedEventArgs" /> (как свойство <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> данных этого события).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2597">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2598">`e` Параметр типизируется как общий базовый тип для всех перенаправленных событий данных; тем не менее, данные события должен быть задан в качестве наиболее конкретный тип данных события, доступные для события, так как <xref:System.Windows.RoutedEventArgs> содержат производные классы определенные свойства данных, предназначенные для конкретного события при его возникновении.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2598">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="4aca4-2599"><xref:System.Windows.RoutedEventArgs> не только свойства состояния для события; Она также определяет, какие перенаправленного события для вызова.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2599"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="4aca4-2600">Этот шаблон генерации событий и данные о событии оба отличаются от [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] классы событий и данных, которые обычно содержат свойства, относящиеся к событию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2600">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-2601">Следующий пример создает данные о событиях, добавляет идентификатор события к данным и затем использует экземпляр данных события для вызова пользовательских перенаправленных событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2601">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberSignature Language="F#" Value="member this.ReleaseAllTouchCaptures : unit -&gt; unit" Usage="contentElement.ReleaseAllTouchCaptures " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-2602">Освобождает все полученные сенсорные устройства для данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2602">Releases all captured touch devices from this element.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseMouseCapture : unit -&gt; unit&#xA;override this.ReleaseMouseCapture : unit -&gt; unit" Usage="contentElement.ReleaseMouseCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-2603">Освобождает мышь, если элемент произвел ее захват.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2603">Releases the mouse capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2604">Если этот элемент не содержит записи, вызов этого метода не оказывает влияния.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2604">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="4aca4-2605">Рекомендуется проверить значение <xref:System.Windows.ContentElement.IsMouseCaptured%2A> перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2605">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4aca4-2606">Следующий обработчик захватывает или отпускает захват мыши в соответствии с ее состояния.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2606">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="4aca4-2607">В примере показано использование записанного мыши целях альтернатива отличные от перемещения указателя мыши в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="4aca4-2607">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseStylusCapture : unit -&gt; unit&#xA;override this.ReleaseStylusCapture : unit -&gt; unit" Usage="contentElement.ReleaseStylusCapture " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-2608">Освобождает перо, если элемент произвел его захват.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2608">Releases the stylus device capture, if this element held the capture.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2609">Если этот элемент не содержит записи, вызов этого метода не оказывает влияния.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2609">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="4aca4-2610">Рекомендуется проверить значение <xref:System.Windows.ContentElement.IsStylusCaptured%2A> перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2610">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberSignature Language="F#" Value="member this.ReleaseTouchCapture : System.Windows.Input.TouchDevice -&gt; bool" Usage="contentElement.ReleaseTouchCapture touchDevice" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" Index="0" FrameworkAlternate="netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="touchDevice"><span data-ttu-id="4aca4-2611">Освобождаемое устройство.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2611">The device to release.</span></span></param>
        <summary><span data-ttu-id="4aca4-2612">Предпринимает попытку освободить заданное сенсорное устройство из этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2612">Attempts to release the specified touch device from this element.</span></span></summary>
        <returns><span data-ttu-id="4aca4-2613">Значение <see langword="true" />, если устройство сенсорного ввода освобождено; в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2613"><see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="4aca4-2614"><paramref name="touchDevice" /> — <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2614"><paramref name="touchDevice" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="abstract member RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit&#xA;override this.RemoveHandler : System.Windows.RoutedEvent * Delegate -&gt; unit" Usage="contentElement.RemoveHandler (routedEvent, handler)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent"><span data-ttu-id="4aca4-2615">Идентификатор перенаправленного события, к которому прикреплен обработчик.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2615">The identifier of the.routed event for which the handler is attached.</span></span></param>
        <param name="handler"><span data-ttu-id="4aca4-2616">Конкретная реализация удаляемого обработчика из коллекции обработчиков событий этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2616">The specific handler implementation to remove from the event handler collection on this element.</span></span></param>
        <summary><span data-ttu-id="4aca4-2617">Удаляет указанный обработчик маршрутизируемого события из этого элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2617">Removes the specified routed event handler from this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2618">Наиболее распространенный сценарий использования это [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] — при реализации [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] событий «оболочки», который связан с пользовательских перенаправленных событий, в частности в том случае, при реализации логики «удалить» для обработчиков [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] уровень.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2618">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="4aca4-2619">Это в следующем примере этот сценарий представлен в разделе "Примечания".</span><span class="sxs-lookup"><span data-stu-id="4aca4-2619">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="4aca4-2620">Вызов этого метода не оказывает влияния, если обработчики, зарегистрированные с критериями, которые соответствуют входные параметры для вызова метода, отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2620">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="4aca4-2621">Если более чем один обработчик подключен, соответствующих критериям, только первый обработчик в удаляется хранилищу обработчика событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2621">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="4aca4-2622">Такое поведение согласуется с [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] поведение `-=` оператор.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2622">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="4aca4-2623">Ни `routedEvent` , ни `handler` может быть `null`.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2623">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="4aca4-2624">Попытка присвоить одно из значений как `null` приведет к появлению исключения.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2624">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="4aca4-2625">Этот метод игнорирует `handledEventsToo` сведения о параметрах, который предоставляется в том случае, если обработчик был первоначально добавлены с классом <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись, которая позволит вам управлять уже обработанных событий.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2625">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="4aca4-2626">Любой из типов обработчика удаляется.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2626">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeCommandBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeCommandBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-2627">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.ContentElement.CommandBindings" /> в экземплярах данного класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2627">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="4aca4-2628">Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.ContentElement.CommandBindings" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2628"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2629">Эта команда возвращает `true` Если <xref:System.Windows.ContentElement.CommandBindings%2A> устанавливается локально.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2629">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="4aca4-2630">Это `ShouldSerialize` метод предоставляется, поскольку <xref:System.Windows.UIElement.CommandBindings%2A> свойство не имеет значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2630">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="4aca4-2631">Этот метод указывает, является ли свойство изменилось со значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2631">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="4aca4-2632">Этот метод обычно вызывается при разработке либо конструктора или разработке собственного элемента управления с включением <xref:System.Windows.UIElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2632">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="4aca4-2633">Дополнительные сведения см. в разделе [определение значения по умолчанию с помощью сброса методов ShouldSerialize и](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2633">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberSignature Language="F#" Value="member this.ShouldSerializeInputBindings : unit -&gt; bool" Usage="contentElement.ShouldSerializeInputBindings " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="4aca4-2634">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.ContentElement.InputBindings" /> в экземплярах данного класса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2634">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span></span></summary>
        <returns><span data-ttu-id="4aca4-2635">Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.ContentElement.InputBindings" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2635"><see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2636">Эта команда возвращает `true` Если <xref:System.Windows.ContentElement.InputBindings%2A> устанавливается локально.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2636">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="4aca4-2637">Это `ShouldSerialize` метод предоставляется, поскольку <xref:System.Windows.UIElement.InputBindings%2A> свойство не имеет значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2637">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="4aca4-2638">Этот метод указывает, является ли свойство изменилось со значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2638">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="4aca4-2639">Этот метод обычно вызывается при разработке либо конструктора или разработке собственного элемента управления с включением <xref:System.Windows.UIElement>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2639">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="4aca4-2640">Дополнительные сведения см. в разделе [определение значения по умолчанию с помощью сброса методов ShouldSerialize и](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2640">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonDown : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2641">Происходит при нажатии кнопки пера в тот момент, когда указатель находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2641">Occurs when the stylus button is pressed while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2642">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusButtonDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2642">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2643">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusButtonDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2643">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2644">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2644">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2645">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2645">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2646">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2646">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2647">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2647">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="4aca4-2648">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2648">Routing strategy</span></span>|<span data-ttu-id="4aca4-2649">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2649">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2650">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2650">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2651">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2651">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2652">Переопределить <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2652">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2653">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusButtonDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2653">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2654">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2654">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2655">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2655">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2656">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2656">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2657">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2657">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2658">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2658">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberSignature Language="F#" Value="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " Usage="member this.StylusButtonUp : System.Windows.Input.StylusButtonEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2659">Происходит при отпускании кнопки пера в тот момент, когда указатель находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2659">Occurs when the stylus button is released while the pointer is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2660">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusButtonUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2660">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2661">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusButtonUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2661">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2662">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2662">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2663">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2663">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2664">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2664">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2665">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2665">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="4aca4-2666">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2666">Routing strategy</span></span>|<span data-ttu-id="4aca4-2667">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2667">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2668">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2668">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="4aca4-2669">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2669">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2670">Переопределить <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2670">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusButtonUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2671">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusButtonUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2671">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2672">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2672">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2673">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2673">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2674">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2674">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2675">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2675">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2676">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2676">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberSignature Language="F#" Value="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " Usage="member this.StylusDown : System.Windows.Input.StylusDownEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2677">Происходит при касании дигитайзера пером в тот момент, когда оно находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2677">Occurs when the stylus touches the digitizer while the stylus is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2678">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusDown> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2678">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2679">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2679">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2680">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2680">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2681">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2681">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2682">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2682">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2683">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2683">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="4aca4-2684">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2684">Routing strategy</span></span>|<span data-ttu-id="4aca4-2685">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2685">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2686">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2686">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="4aca4-2687">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2687">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2688">Переопределить <xref:System.Windows.ContentElement.OnStylusDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2688">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2689">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2689">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2690">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2690">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2691">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2691">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2692">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2692">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2693">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2693">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2694">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2694">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberSignature Language="F#" Value="member this.StylusEnter : System.Windows.Input.StylusEventHandler " Usage="member this.StylusEnter : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2695">Происходит, когда перо попадает внутрь границ данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2695">Occurs when the stylus enters the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2696"><xref:System.Windows.ContentElement.StylusEnter> — [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2696"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="4aca4-2697">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2697">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="4aca4-2698">Тем не менее они включают другие аспекты поведения перенаправленного события, такие как триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2698">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="4aca4-2699">Несмотря на то что <xref:System.Windows.ContentElement.StylusEnter> отслеживает, когда перо попадает внутрь границ элемента, это событие дополнительные буквально о том, что <xref:System.Windows.ContentElement.IsStylusOver%2A> значение свойства было изменено с `false` для `true` данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2699">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="4aca4-2700">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusEnter> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2700">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2701">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusEnter> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2701">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2702">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2702">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2703">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2703">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2704">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2704">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2705">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2705">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="4aca4-2706">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2706">Routing strategy</span></span>|<span data-ttu-id="4aca4-2707">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2707">Direct</span></span>|  
|<span data-ttu-id="4aca4-2708">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2708">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2709">Переопределить <xref:System.Windows.ContentElement.OnStylusEnter%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2709">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2710">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusEnter" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2710">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2711">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2711">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2712">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2712">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2713">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2713">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2714">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2714">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2715">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2715">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberSignature Language="F#" Value="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInAirMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2716">Происходит при движении пера над элементом без касания дигитайзера.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2716">Occurs when the stylus moves over an element without actually touching the digitizer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2717">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusInAirMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2717">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2718">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusInAirMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2718">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2719">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2719">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2720">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2720">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2721">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2721">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2722">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2722">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="4aca4-2723">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2723">Routing strategy</span></span>|<span data-ttu-id="4aca4-2724">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2724">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2725">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2725">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2726">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2726">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2727">Переопределить <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2727">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInAirMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2728">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusInAirMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2728">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2729">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2729">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2730">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2730">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2731">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2731">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2732">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2732">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2733">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2733">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberSignature Language="F#" Value="member this.StylusInRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusInRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2734">Происходит при нахождении пера над данным элементом достаточно близко для того, чтобы перо было обнаружено дигитайзером.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2734">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2735">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusInRange> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2735">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2736">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusInRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2736">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2737">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2737">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2738">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2738">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2739">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2739">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2740">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2740">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="4aca4-2741">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2741">Routing strategy</span></span>|<span data-ttu-id="4aca4-2742">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2742">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2743">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2743">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2744">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2744">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="4aca4-2745">Переопределить <xref:System.Windows.ContentElement.OnStylusInRange%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2745">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusInRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2746">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusInRange" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2746">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2747">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2747">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2748">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2748">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2749">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2749">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2750">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2750">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2751">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2751">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberSignature Language="F#" Value="member this.StylusLeave : System.Windows.Input.StylusEventHandler " Usage="member this.StylusLeave : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2752">Происходит, когда перо покидает границы элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2752">Occurs when the stylus leaves the bounds of the element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2753"><xref:System.Windows.ContentElement.StylusLeave> — [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2753"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="4aca4-2754">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2754">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="4aca4-2755">Тем не менее они включают другие аспекты поведения перенаправленного события, такие как триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2755">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="4aca4-2756">Несмотря на то что <xref:System.Windows.ContentElement.StylusLeave> отслеживает, когда перо покидает границы элемента, это событие, сведения о том, что буквально <xref:System.Windows.ContentElement.IsStylusOver%2A> значение свойства было изменено с `true` для `false` данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2756">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="4aca4-2757">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusLeave> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2757">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2758">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusLeave> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2758">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2759">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2759">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2760">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2760">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2761">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2761">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2762">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2762">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="4aca4-2763">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2763">Routing strategy</span></span>|<span data-ttu-id="4aca4-2764">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2764">Direct</span></span>|  
|<span data-ttu-id="4aca4-2765">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2765">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2766">Переопределить <xref:System.Windows.ContentElement.OnStylusLeave%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2766">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2767">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusLeave" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2767">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2768">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2768">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2769">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2769">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2770">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2770">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2771">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2771">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2772">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2772">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberSignature Language="F#" Value="member this.StylusMove : System.Windows.Input.StylusEventHandler " Usage="member this.StylusMove : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2773">Происходит при движении пера над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2773">Occurs when the stylus moves over this element.</span></span> <span data-ttu-id="4aca4-2774">Для вызова этого события перо должно перемещаться по дигитайзеру.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2774">The stylus must move while on the digitizer to raise this event.</span></span> <span data-ttu-id="4aca4-2775">В противном случае вызывается событие <see cref="E:System.Windows.ContentElement.StylusInAirMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2775">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2776">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusMove> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2776">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2777">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2777">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2778">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2778">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2779">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2779">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2780">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2780">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2781">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2781">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="4aca4-2782">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2782">Routing strategy</span></span>|<span data-ttu-id="4aca4-2783">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2783">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2784">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2784">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2785">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2785">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2786">Переопределить <xref:System.Windows.ContentElement.OnStylusMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2786">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2787">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2787">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2788">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2788">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2789">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2789">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2790">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2790">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2791">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2791">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2792">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2792">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberSignature Language="F#" Value="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " Usage="member this.StylusOutOfRange : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2793">Возникает, когда расстояние между пером и дигитайзером слишком велико для обнаружения пера при условии, что перо находится над этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2793">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2794">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusOutOfRange> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2794">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2795">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusOutOfRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2795">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2796">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2796">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2797">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2797">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2798">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2798">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2799">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2799">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="4aca4-2800">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2800">Routing strategy</span></span>|<span data-ttu-id="4aca4-2801">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2801">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2802">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2802">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2803">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2803">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="4aca4-2804">Переопределить <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2804">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusOutOfRangeEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2805">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusOutOfRange" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2805">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2806">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2806">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2807">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2807">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2808">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2808">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2809">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2809">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2810">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2810">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberSignature Language="F#" Value="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " Usage="member this.StylusSystemGesture : System.Windows.Input.StylusSystemGestureEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2811">Происходит при использовании пользователем одного из жестов пером.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2811">Occurs when a user performs one of several stylus gestures.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2812">Дополнительные сведения о жестов пером, см. в разделе <xref:System.Windows.Input.SystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2812">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="4aca4-2813">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusSystemGesture> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2813">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2814">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusSystemGesture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2814">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2815">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2815">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2816">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2816">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2817">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2817">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2818">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2818">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="4aca4-2819">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2819">Routing strategy</span></span>|<span data-ttu-id="4aca4-2820">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2820">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2821">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2821">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="4aca4-2822">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2822">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="4aca4-2823">Переопределить <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2823">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusSystemGestureEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2824">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusSystemGesture" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2824">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2825">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2825">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2826">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2826">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2827">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2827">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2828">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2828">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2829">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2829">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberSignature Language="F#" Value="member this.StylusUp : System.Windows.Input.StylusEventHandler " Usage="member this.StylusUp : System.Windows.Input.StylusEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2830">Происходит, когда пользователь отрывает перо от поверхности дигитайзера в тот момент, когда оно находится над этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2830">Occurs when the user raises the stylus off the digitizer while it is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2831">Это событие создает псевдоним для <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.StylusUp> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2831">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2832">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2832">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="4aca4-2833">Прикосновений, мыши и ввод с помощью пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2833">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="4aca4-2834">Дополнительные сведения см. в разделе [Общие сведения о входных данных](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="4aca4-2834">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2835">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2835">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2836">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2836">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="4aca4-2837">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2837">Routing strategy</span></span>|<span data-ttu-id="4aca4-2838">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2838">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2839">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2839">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="4aca4-2840">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2840">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2841">Переопределить <xref:System.Windows.ContentElement.OnStylusUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2841">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable StylusUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.StylusUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2842">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2842">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2843">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2843">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2844">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2844">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2845">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2845">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2846">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2846">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2847">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2847">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberSignature Language="F#" Value="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " Usage="member this.TextInput : System.Windows.Input.TextCompositionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2848">Происходит при получении этим элементом текста аппаратно-независимым способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2848">Occurs when this element gets text in a device-independent manner.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4aca4-2849">Это событие уже может быть помечено как обработанное внутренними реализациями составных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2849">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="4aca4-2850">См. примечание ниже.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2850">See Remark below.</span></span>  
  
 <span data-ttu-id="4aca4-2851"><xref:System.Windows.ContentElement.TextInput> Событие уже может быть отмечено как обработанное внутренней реализации составных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2851">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="4aca4-2852">Например <xref:System.Windows.Controls.TextBox> — это составной элемент управления где <xref:System.Windows.ContentElement.TextInput> событие уже помечено как обработанное; внутри элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2852">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="4aca4-2853">Элементы управления этого, так как элемент управления должен интерпретировать некоторые виды входные данные, например клавиш со стрелками, как имеющие специальное значение для этого элемента управления.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2853">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="4aca4-2854">Если вы используете <xref:System.Windows.ContentElement.PreviewTextInput> как событие, где присоединения обработчиков для ввода текста, может появиться лучшие результаты.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2854">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="4aca4-2855">Этот метод помогает в большинстве случаев, где уже пометил это событие, как обработанное композиции элемента управления и предотвращает получение событий на маршруте события Ваш обработчик.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2855">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="4aca4-2856"><xref:System.Windows.ContentElement.TextInput> Событие позволяет компонента или приложения для ожидания передачи данных для ввода текста в аппаратно независимым способом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2856">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="4aca4-2857">Клавиатура является основным средством <xref:System.Windows.ContentElement.TextInput>, но также может вызывать речи, рукописного ввода и других устройств ввода <xref:System.Windows.ContentElement.TextInput>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2857">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="4aca4-2858">Из-за сочетания клавиш - клавиатуры по умолчанию или редакторам методов ввода — несколько ключевых событий может вызвать только одно событие ввода текста.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2858">Because of key combinations - either in default keyboards or through input method editors - multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="4aca4-2859">Это событие создает псевдоним для <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> присоединенного события для этого класса, чтобы <xref:System.Windows.ContentElement.TextInput> является частью класса список членов, когда <xref:System.Windows.ContentElement> наследуется как базовый элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2859">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="4aca4-2860">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.TextInput> событий присоединяются к базовому объекту <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> присоединенного события и получать один и тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2860">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2861">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2861">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2862">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2862">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="4aca4-2863">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2863">Routing strategy</span></span>|<span data-ttu-id="4aca4-2864">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2864">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2865">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2865">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="4aca4-2866">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTextInput>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2866">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="4aca4-2867">Переопределить <xref:System.Windows.ContentElement.OnTextInput%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2867">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TextInputEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TextInputEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2868">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TextInput" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2868">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2869">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2869">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="4aca4-2870">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2870">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="4aca4-2871">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2871">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="4aca4-2872">Дополнительные сведения о регистрации перенаправленных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2872">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="4aca4-2873">Дополнительные сведения об использовании идентификаторов перенаправленных событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2873">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberSignature Language="F#" Value="member this.TouchDown : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchDown : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2874">Происходит при касании пальцем экрана, когда палец находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2874">Occurs when a finger touches the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2875">По умолчанию <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> пока палец касается экрана и перемещает события не происходят.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2875">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="4aca4-2876">Нажав пальцем на экране и удерживает без его перемещения то прессе и удерживайте поведение <xref:System.Windows.Input.Stylus>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2876">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="4aca4-2877">Нажмите и удерживайте клавишу поведение соответствует щелчку правой кнопкой мыши.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2877">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="4aca4-2878">Чтобы вызвать <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> событий по мере палец касается экрана, задать <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> вложенное свойство, чтобы `false` для данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2878">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2879">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2879">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2880">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2880">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="4aca4-2881">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2881">Routing strategy</span></span>|<span data-ttu-id="4aca4-2882">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2882">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2883">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2883">Delegate</span></span>|<span data-ttu-id="4aca4-2884"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2884"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2885">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTouchDown>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2885">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="4aca4-2886">Переопределить <xref:System.Windows.ContentElement.OnTouchDown%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2886">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchDownEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchDownEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2887">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchDown" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2887">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberSignature Language="F#" Value="member this.TouchEnter : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchEnter : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2888">Происходит при перемещении касания внутрь данного элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2888">Occurs when a touch moves from outside to inside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4aca4-2889">Это событие вызывается всегда, независимо от захвата сенсорного устройства этот элемент пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2889">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2890">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2890">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2891">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2891">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="4aca4-2892">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2892">Routing strategy</span></span>|<span data-ttu-id="4aca4-2893">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2893">Direct</span></span>|  
|<span data-ttu-id="4aca4-2894">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2894">Delegate</span></span>|<span data-ttu-id="4aca4-2895"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2895"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2896">Переопределить <xref:System.Windows.ContentElement.OnTouchEnter%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2896">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchEnterEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchEnterEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2897">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchEnter" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2897">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCaptured : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCaptured" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2898">Получает все сенсорные устройства, переданные в данный элемент.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2898">Gets all touch devices that are captured to this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-2899">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, полученных этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2899">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesCapturedWithin : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2900">Получает все сенсорные устройства, переданные в этот элемент или какой-либо из его дочерних элементов в визуальном дереве.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2900">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="4aca4-2901">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, полученных этим элементом или каким-либо из его дочерних элементов в визуальном дереве.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2901">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesDirectlyOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2902">Получает все сенсорные устройства, находящиеся над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2902">Gets all touch devices that are over this element.</span></span></summary>
        <value><span data-ttu-id="4aca4-2903">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, находящихся над этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2903">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TouchesOver : seq&lt;System.Windows.Input.TouchDevice&gt;" Usage="System.Windows.ContentElement.TouchesOver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2904">Получает все сенсорные устройства, находящиеся над этим элементом или каким-либо из его дочерних элементов в визуальном дереве.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2904">Gets all touch devices that are over this element or any child elements in its visual tree.</span></span></summary>
        <value><span data-ttu-id="4aca4-2905">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, которые находятся над этим элементом или каким-либо из его дочерних элементов в визуальном дереве.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2905">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberSignature Language="F#" Value="member this.TouchLeave : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchLeave : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2906">Происходит при перемещении касания за границы элемента.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2906">Occurs when a touch moves from inside to outside the bounds of this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2907">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2907">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2908">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2908">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="4aca4-2909">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2909">Routing strategy</span></span>|<span data-ttu-id="4aca4-2910">Direct</span><span class="sxs-lookup"><span data-stu-id="4aca4-2910">Direct</span></span>|  
|<span data-ttu-id="4aca4-2911">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2911">Delegate</span></span>|<span data-ttu-id="4aca4-2912"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2912"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2913">Переопределить <xref:System.Windows.ContentElement.OnTouchLeave%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2913">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchLeaveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2914">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchLeave" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2914">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberSignature Language="F#" Value="member this.TouchMove : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchMove : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2915">Возникает при перемещении пальца по экрану при условии, если палец находится над данным элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2915">Occurs when a finger moves on the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2916">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2916">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2917">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2917">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="4aca4-2918">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2918">Routing strategy</span></span>|<span data-ttu-id="4aca4-2919">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2919">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2920">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2920">Delegate</span></span>|<span data-ttu-id="4aca4-2921"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2921"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2922">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTouchMove>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2922">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="4aca4-2923">Переопределить <xref:System.Windows.ContentElement.OnTouchMove%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2923">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchMoveEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchMoveEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2924">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchMove" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2924">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberSignature Language="F#" Value="member this.TouchUp : EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " Usage="member this.TouchUp : System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2925">Возникает, когда палец отрывается от экрана при условии, что палец находится над этим элементом.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2925">Occurs when a finger is raised off of the screen while the finger is over this element.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="4aca4-2926">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="4aca4-2926">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="4aca4-2927">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="4aca4-2927">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="4aca4-2928">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="4aca4-2928">Routing strategy</span></span>|<span data-ttu-id="4aca4-2929">Восходящая маршрутизация</span><span class="sxs-lookup"><span data-stu-id="4aca4-2929">Bubbling</span></span>|  
|<span data-ttu-id="4aca4-2930">делегат</span><span class="sxs-lookup"><span data-stu-id="4aca4-2930">Delegate</span></span>|<span data-ttu-id="4aca4-2931"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2931"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="4aca4-2932">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTouchUp>.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2932">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="4aca4-2933">Переопределить <xref:System.Windows.ContentElement.OnTouchUp%2A> реализовать обработчик класса для этого события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2933">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberSignature Language="F#" Value=" staticval mutable TouchUpEvent : System.Windows.RoutedEvent" Usage="System.Windows.ContentElement.TouchUpEvent" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="4aca4-2934">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchUp" />.</span><span class="sxs-lookup"><span data-stu-id="4aca4-2934">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>